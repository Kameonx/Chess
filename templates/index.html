<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: white;
        }
        
        #game-info {
            margin: 20px 0;
            font-size: 24px;
        }
        
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            touch-action: zoom-in;
            position: relative;
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        
        .white { background-color: #f0d9b5; }
        .black { background-color: #b58863; }
        
        #captured-white, #captured-black {
            margin: 10px 0;
            font-size: 20px;
        }
        
        .piece-image {
            max-width: 80px;
            max-height: 80px;
        }
        
        .valid-move {
            background-color: rgba(0, 255, 0, 0.5);
        }
        
        .castle-move {
            background-color: rgba(0, 0, 255, 0.5);
        }
        
        #restart-btn {
            padding: 10px 20px;
            font-size: 18px;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .check-indicator {
            font-weight: bold;
        }

        .check-notification {
            color: yellow; /* Change this to your desired color for check */
        }
        
        .checkmate-notification {
            color: red; /* Keep red for checkmate */
            font-weight: bold;
        }
        
        #promotion-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        .promotion-option {
            cursor: pointer;
            margin: 5px;
        }
        
        .grid-label {
            position: absolute;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .grid-label.top-left {
            top: 2px;
            left: 2px;
        }
        
        .grid-label.bottom-right {
            bottom: 2px;
            right: 2px;
        }
        
        @media (max-width: 600px) {
            #chessboard {
                grid-template-columns: repeat(8, 50px);
                grid-template-rows: repeat(8, 50px);
            }
            
            .piece-image {
                max-width: 50px;
                max-height: 50px;
            }
        }
        
        #sound-icon {
            position: fixed;
            bottom: 10px;
            right: 10px;
            cursor: pointer;
            width: 30px;
            height: 30px;
        }
        
        #sound-icon img {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="game-info">
        <div id="turn-display"></div>
        <div id="check-display" class="check-indicator"></div>
    </div>
    <div id="chessboard"></div>
    <div id="captured-white">Captured White: <span id="captured-white-list"></span></div>
    <div id="captured-black">Captured Black: <span id="captured-black-list"></span></div>
    <button id="restart-btn" onclick="restartGame()">Restart Game</button>
    <button id="toggle-grid-btn" onclick="toggleGridLabels()">Toggle Grid Labels</button>
    <div id="promotion-modal">
        <div>Select promotion piece:</div>
        <div id="promotion-options"></div>
    </div>
    <audio id="background-music" src="/audio/Chess Type Beat _ joyful - chess (slowed).mp3" loop autoplay></audio>
    <div id="sound-icon" onclick="toggleSound()">
        <img src="/static/sound-on.png" alt="Sound On">
    </div>
    <script>
    const board = document.getElementById('chessboard');
    const capturedWhite = document.getElementById('captured-white-list');
    const capturedBlack = document.getElementById('captured-black-list');
    const restartBtn = document.getElementById('restart-btn');
    const turnDisplay = document.getElementById('turn-display');
    const checkDisplay = document.getElementById('check-display');
    const promotionModal = document.getElementById('promotion-modal');
    const promotionOptions = document.getElementById('promotion-options');
    const backgroundMusic = document.getElementById('background-music');
    const soundIcon = document.getElementById('sound-icon').querySelector('img');
    let gameState = {};
    let promoColor = '';
    let promoIndex = 0;
    let showGridLabels = true;

    function createBoard() {
        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        for (let i = 0; i < 64; i++) {
            const square = document.createElement('div');
            square.classList.add('square');
            if ((Math.floor(i / 8) + i % 8) % 2 === 0) {
                square.classList.add('white');
            } else {
                square.classList.add('black');
            }
            square.dataset.index = i;
            square.addEventListener('click', () => handleSquareClick(i));
            
            const row = 8 - Math.floor(i / 8);
            const col = files[i % 8];
            
            const topLeftLabel = document.createElement('div');
            topLeftLabel.classList.add('grid-label', 'top-left');
            topLeftLabel.textContent = `${col}${row}`;
            
            square.appendChild(topLeftLabel);
            
            board.appendChild(square);
        }
    }

    function handleSquareClick(index) {
        const row = Math.floor(index / 8);
        const col = index % 8;
        
        // Check if there's a piece at the clicked position
        const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        
        // If no piece is selected and we clicked on a piece of the current turn's color
        if (gameState.selection === 100) {
            if ((gameState.turn_step % 2 === 0 && whiteIndex !== -1) || 
                (gameState.turn_step % 2 === 1 && blackIndex !== -1)) {
                const piece_index = gameState.turn_step % 2 === 0 ? whiteIndex : blackIndex;
                gameState.selection = piece_index;
                gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                    gameState.white_options[piece_index] : 
                    gameState.black_options[piece_index];
                updateBoard();
            }
        } else {
            const move = [col, row];
            const validMove = gameState.valid_moves.some(vm => {
                if (Array.isArray(vm)) {
                    return vm[0] === col && vm[1] === row;
                }
                return false;
            });
            
            if (validMove) {
                fetch('/move', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        piece_index: gameState.selection,
                        move: move
                    })
                })
                .then(response => response.json())
                .then(data => {
                    gameState = data;
                    updateBoard();
                })
                .catch(error => console.error('Error:', error));
            } else {
                // Deselect if clicking on an invalid move location
                gameState.selection = 100;
                gameState.valid_moves = [];
                updateBoard();
            }
        }
    }

    function handlePromotion() {
        if (gameState.white_promote || gameState.black_promote) {
            promoColor = gameState.white_promote ? 'white' : 'black';
            promoIndex = gameState.promo_index;
            promotionOptions.innerHTML = '';
            const promotions = promoColor === 'white' ? ['queen', 'rook', 'bishop', 'knight'] : ['queen', 'rook', 'bishop', 'knight'];
            promotions.forEach(piece => {
                const option = document.createElement('div');
                option.classList.add('promotion-option');
                option.textContent = piece;
                option.addEventListener('click', () => selectPromotion(piece));
                promotionOptions.appendChild(option);
            });
            promotionModal.style.display = 'block';
        } else {
            promotionModal.style.display = 'none';
        }
    }

    function selectPromotion(piece) {
        fetch('/promote', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ piece: piece })
        })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            updateBoard();
        })
        .catch(error => {
            console.error('Error promoting pawn:', error);
        });
    }

    function updateBoard() {
        const squares = document.querySelectorAll('.square');
        squares.forEach(square => {
            square.innerHTML = '';
            const index = parseInt(square.dataset.index);
            const row = Math.floor(index / 8);
            const col = index % 8;

            // Clear previous valid moves
            square.classList.remove('valid-move', 'castle-move');

            // Add valid moves highlighting
            if (gameState.valid_moves) {
                const isValidMove = gameState.valid_moves.some(move => {
                    if (Array.isArray(move)) {
                        return move[0] === col && move[1] === row;
                    }
                    return false;
                });
                if (isValidMove) {
                    square.classList.add('valid-move');
                }
                const isCastleMove = gameState.valid_moves.some(move => {
                    if (Array.isArray(move) && move.length === 3 && move[2].includes('castle')) {
                        return move[0] === col && move[1] === row;
                    }
                    return false;
                });
                if (isCastleMove) {
                    square.classList.add('castle-move');
                }
            }

            // Add pieces
            const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
            const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);

            if (whiteIndex !== -1) {
                const piece = gameState.white_pieces[whiteIndex];
                const img = document.createElement('img');
                img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}lt60.png`;
                img.classList.add('piece-image');
                square.appendChild(img);
            } else if (blackIndex !== -1) {
                const piece = gameState.black_pieces[blackIndex];
                const img = document.createElement('img');
                img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}dt60.png`;
                img.classList.add('piece-image');
                square.appendChild(img);
            }

            // Re-add grid labels if enabled
            if (showGridLabels) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const rowLabel = 8 - Math.floor(index / 8);
                const colLabel = files[index % 8];
                
                const topLeftLabel = document.createElement('div');
                topLeftLabel.classList.add('grid-label', 'top-left');
                topLeftLabel.textContent = `${colLabel}${rowLabel}`;
                
                square.appendChild(topLeftLabel);
            }
        });

        // Update other game information
        capturedWhite.textContent = gameState.captured_pieces_white.join(', ');
        capturedBlack.textContent = gameState.captured_pieces_black.join(', ');
        const turnColor = gameState.turn_step % 2 === 0 ? 'WHITE' : 'BLACK';
        turnDisplay.textContent = `Current Turn: ${turnColor}`;
        
        if (gameState.check) {
            checkDisplay.textContent = `${gameState.check.toUpperCase()} IS IN CHECK!`;
            checkDisplay.className = 'check-indicator check-notification';
        } else {
            checkDisplay.textContent = '';
            checkDisplay.className = 'check-indicator';
        }
        
        if (gameState.game_over) {
            checkDisplay.textContent = `${gameState.winner.toUpperCase()} WINS BY CHECKMATE!`;
            checkDisplay.className = 'check-indicator checkmate-notification';
        }
    }

    function toggleGridLabels() {
        showGridLabels = !showGridLabels;
        updateBoard();
    }

    function restartGame() {
        fetch('/restart', {
            method: 'POST'
        })
        .then(response => response.json())
        .then(data => {
            // Reset the game state with all the necessary properties
            gameState = {
                white_pieces: data.white_pieces,
                white_locations: data.white_locations,
                black_pieces: data.black_pieces,
                black_locations: data.black_locations,
                captured_pieces_white: data.captured_pieces_white,
                captured_pieces_black: data.captured_pieces_black,
                turn_step: data.turn_step,
                selection: data.selection,
                valid_moves: data.valid_moves,
                white_options: data.white_options,
                black_options: data.black_options,
                winner: data.winner,
                game_over: data.game_over,
                check: data.check,
                white_moved: data.white_moved,
                black_moved: data.black_moved
            };
            updateBoard();
        })
        .catch(error => {
            console.error('Error restarting game:', error);
        });
    }

    function toggleSound() {
        if (backgroundMusic.muted) {
            backgroundMusic.muted = false;
            soundIcon.src = '/static/sound-on.png';
            backgroundMusic.play(); // This will resume playback
        } else {
            backgroundMusic.muted = true;
            soundIcon.src = '/static/sound-off.png';
        }
    }

    window.onload = () => {
        createBoard();
        fetch('/state', {
            method: 'GET'
        })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            updateBoard();
            // Add this code to handle autoplay
            backgroundMusic.muted = false;
            // Try to play immediately
            let playPromise = backgroundMusic.play();
            
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    // Auto-play was prevented
                    console.log("Autoplay was prevented by browser");
                    // Add a click event listener to the document to enable audio
                    document.addEventListener('click', function enableAudio() {
                        backgroundMusic.play();
                        document.removeEventListener('click', enableAudio);
                    }, { once: true });
                });
            }
        })
        .catch(error => {
            console.error('Error fetching game state:', error);
        });
    };
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: white;
        }
        #game-info {
            margin: 20px 0;
            font-size: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        #turn-display { margin-bottom: 5px; }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            touch-action: zoom-in;
            position: relative;
            transform: rotate(180deg);
        }
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transform: rotate(180deg);
        }
        .white { background-color: #f0d9b5; }
        .black { background-color: #b58863; }
        #captured-white, #captured-black {
            margin: 10px 0;
            font-size: 20px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            min-height: 40px;
        }
        .captured-piece { width: 30px; height: 30px; margin: 2px; }
        .piece-image {
            max-width: 80px;
            max-height: 80px;
            user-select: none;
        }
        .valid-move { background-color: rgba(0, 255, 0, 0.5); }
        .castle-move { background-color: rgba(0, 0, 255, 0.5) !important; }
        #restart-btn { padding: 10px 20px; font-size: 18px; margin: 10px 0; cursor: pointer; }
        .check-indicator { font-weight: bold; }
        .check-notification { color: yellow; }
        .checkmate-notification {
            color: #ff0000;
            font-weight: bold;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #promotion-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            text-align: center;
        }
        .promotion-option {
            display: inline-block;
            cursor: pointer;
            margin: 10px;
            padding: 10px;
            border-radius: 5px;
            background-color: #3a3a3a;
            transition: background-color 0.3s;
        }
        .promotion-option:hover { background-color: #4a4a4a; }
        .promotion-option img { width: 60px; height: 60px; }
        .grid-label {
            position: absolute;
            font-size: 14px;
            color: rgba(180, 180, 180, 0.9);
        }
        .grid-label.top-left { top: 2px; left: 2px; }
        .grid-label.bottom-right { bottom: 2px; right: 2px; }
        #chessboard-wrapper { position: relative; padding: 25px; margin-bottom: 10px; }
        .outside-label {
            position: absolute;
            font-size: 16px;
            color: rgba(180, 180, 180, 0.9);
            text-align: center;
        }
        .column-label { width: 100px; height: 20px; line-height: 20px; }
        .row-label { width: 20px; height: 100px; line-height: 100px; }
        .button-row { display: flex; gap: 10px; margin: 10px 0; }
        #restart-btn, #toggle-grid-btn { padding: 10px 20px; font-size: 18px; cursor: pointer; }
        .promotion-option.selected {
            background-color: #5a5a5a;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        .piece-dragging {
            opacity: 0.8;
            cursor: grabbing;
            pointer-events: none;
            position: fixed;
            z-index: 1000;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            transition: none;
        }
        .square.drag-over { box-shadow: inset 0 0 10px #ffff00; }
        .square.valid-drop-target { background-color: rgba(0, 255, 0, 0.3); }
        .square.valid-drop-target.castle-move { background-color: rgba(0, 0, 255, 0.5) !important; }
        .last-move-from { box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.5); }
        .last-move-to { box-shadow: inset 0 0 0 4px rgba(255, 165, 0, 0.7); }
        #move-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            transform: rotate(180deg);
        }
        #move-arrow svg {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            width: 200px;
            order: 3;
        }
        #restart-btn, #toggle-grid-btn, #ai-btn {
            padding: 10px 0;
            font-size: 18px;
            cursor: pointer;
            width: 100%;
            margin: 0;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s;
        }
        #restart-btn { background-color: #d9534f; }
        #restart-btn:hover { background-color: #c9302c; }
        #toggle-grid-btn { background-color: #5bc0de; }
        #toggle-grid-btn:hover { background-color: #46b8da; }
        #ai-btn { background-color: #5cb85c; }
        #ai-btn:hover { background-color: #4cae4c; }
        #sound-icon {
            position: fixed;
            bottom: 15px;
            right: 15px;
            cursor: pointer;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: 50%;
            padding: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        #sound-icon img {
            width: 100%;
            height: 100%;
        }
        /* Add mobile-specific responsive styles */
        @media (max-width: 768px) {
            #chessboard {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }
            .piece-image {
                max-width: 35px;
                max-height: 35px;
                touch-action: none; /* Prevent browser handling of touches */
            }
            .button-container {
                width: 100%;
                padding: 0 15px;
                box-sizing: border-box;
            }
            .outside-label {
                font-size: 12px;
            }
            .grid-label {
                font-size: 10px;
            }
            #sound-icon {
                width: 18px;
                height: 18px;
                padding: 3px;
            }
            .captured-piece {
                width: 20px;
                height: 20px;
                margin: 1px;
            }
            body.dragging {
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
            #move-arrow { 
                transform: rotate(180deg);
                z-index: 30;
                display: block !important;
                opacity: 1 !important;
            }
            .valid-move {
                background-color: rgba(0, 255, 0, 0.7) !important;
                box-shadow: inset 0 0 12px #00ff00;
            }
            .castle-move {
                background-color: rgba(0, 0, 255, 0.7) !important;
                box-shadow: inset 0 0 12px #0000ff;
            }
            .piece-dragging {
                width: 50px;
                height: 50px;
                opacity: 1 !important;
                z-index: 2000 !important;
                pointer-events: none;
                position: absolute; /* Use absolute instead of fixed for better positioning */
                box-shadow: 0 0 10px rgba(0,0,0,0.5);
            }
        }
        
        /* Enhance drag and drop appearance */
        .piece-dragging {
            opacity: 1;
            cursor: grabbing;
            pointer-events: none;
            position: absolute; /* Use absolute instead of fixed for better positioning */
            z-index: 1000;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            transition: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        @media (max-width: 768px) {
            /* Improve touch handling on mobile */
            .piece-image {
                touch-action: none; /* Prevent browser handling of touches */
            }
            .piece-dragging {
                width: 50px !important;
                height: 50px !important;
                opacity: 1 !important;
                z-index: 2000 !important;
                transform: none !important; /* Don't use translate which can cause positioning issues */
                position: absolute; /* Use absolute instead of fixed for better positioning */
            }
        }
        /* Make valid move indicators more visible on desktop */
        .valid-move {
            background-color: rgba(0, 255, 0, 0.6) !important; /* Increased opacity */
            box-shadow: inset 0 0 6px #00ff00 !important; /* Added glow effect */
        }
        .castle-move {
            background-color: rgba(0, 0, 255, 0.6) !important; 
            box-shadow: inset 0 0 6px #0000ff !important;
        }
        /* Fix CSS comment syntax in media query */
        @media (max-width: 768px) {
            /* Existing mobile styles */
            /* Remove incorrect comment style that uses // instead of /* */
        }
        /* Fix the piece-dragging styling for mobile */
        @media (max-width: 768px) {
            .piece-dragging {
                width: 40px !important;
                height: 40px !important;
                opacity: 0.9 !important;
                z-index: 2000 !important;
                position: fixed !important; /* Use fixed for mobile */
                transform: none !important;
                pointer-events: none;
                box-shadow: 0 0 10px rgba(0,0,0,0.5);
                top: 0;
                left: 0;
            }
        }
        
        /* Update desktop styling as well to be consistent */
        .piece-dragging {
            opacity: 0.9;
            cursor: grabbing;
            pointer-events: none;
            position: fixed;
            z-index: 1000;
            width: 70px;
            height: 70px;
            transform: none; 
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .selected-square {
            box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.8) !important;
            background-color: rgba(255, 215, 0, 0.3) !important;
            z-index: 1;
        }
        #ai-difficulty-container {
            display: flex;
            flex-direction: row;
            gap: 5px;
            width: 100%;
            margin-bottom: 10px;
        }

        #ai-difficulty-container button {
            flex: 1;
            background-color: #D4AF37;
            color: white;
            padding: 8px 0;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #ai-difficulty-container button:hover {
            background-color: #C5A028;
        }
    </style>
</head>
<body>
    <div id="game-info">
        <div id="turn-display"></div>
        <div id="check-display" class="check-indicator"></div>
    </div>
    <div id="chessboard"></div>
    <div id="move-arrow"><svg></svg></div>
    <div id="captured-white">Captured White: <div id="captured-white-list" class="captured-pieces-container"></div></div>
    <div id="captured-black">Captured Black: <div id="captured-black-list" class="captured-pieces-container"></div></div>
    <div class="button-container">
        <button id="restart-btn" onclick="restartGame()">Restart Game</button>
        <button id="ai-btn" onclick="playVsAI()">Play vs AI</button>
        <button id="toggle-grid-btn" onclick="toggleGridLabels()">Grid Labels</button>
    </div>
    <div id="promotion-modal">
        <div style="color: white; margin-bottom: 15px; font-size: 20px;">Choose promotion piece:</div>
        <div id="promotion-options"></div>
    </div>
    <audio id="background-music" src="/audio/Chess Type Beat _ joyful - chess (slowed).mp3" loop muted></audio>
    <div id="sound-icon" onclick="toggleSound()">
        <img src="/static/sound-off.png" alt="Sound Off">
    </div>
    <script>
    const board = document.getElementById('chessboard');
    const capturedWhite = document.getElementById('captured-white-list');
    const capturedBlack = document.getElementById('captured-black-list');
    const restartBtn = document.getElementById('restart-btn');
    const turnDisplay = document.getElementById('turn-display');
    const checkDisplay = document.getElementById('check-display');
    const promotionModal = document.getElementById('promotion-modal');
    const promotionOptions = document.getElementById('promotion-options');
    const backgroundMusic = document.getElementById('background-music');
    const soundIcon = document.getElementById('sound-icon').querySelector('img');
    let draggedPiece = null;
    let draggedPieceIndex = -1;
    let validDropTargets = [];
    let gridLabelMode = 3;
    let playingVsAI = false;
    let gameState = null;
    let draggedPieceRect = null;  // NEW global variable to store the piece's bounding rectangle

    function createBoard() {
        let wrapper = document.getElementById('chessboard-wrapper');
        if (!wrapper) {
            wrapper = document.createElement('div');
            wrapper.id = 'chessboard-wrapper';
            board.parentNode.insertBefore(wrapper, board);
            wrapper.appendChild(board);
        }
        for (let i = 0; i < 64; i++) {
            const square = document.createElement('div');
            square.dataset.index = i;
            square.classList.add('square');
            if ((Math.floor(i / 8) + i % 8) % 2 === 0) {
                square.classList.add('white');
            } else {
                square.classList.add('black');
            }
            square.addEventListener('click', () => handleSquareClick(i));
            square.addEventListener('dragover', (e) => handleDragOver(e, i));
            square.addEventListener('drop', (e) => handleDrop(e, i));
            square.addEventListener('dragenter', (e) => handleDragEnter(e, i));
            square.addEventListener('dragleave', handleDragLeave);
            board.appendChild(square);
        }
        createOutsideLabels();
        updateGridButtonText();
        
        const moveArrow = document.getElementById('move-arrow');
        wrapper.appendChild(moveArrow);
    }

// Update the createOutsideLabels function to center labels properly
function createOutsideLabels() {
    // Remove any existing outside labels
    document.querySelectorAll('.outside-label').forEach(el => el.remove());
    const files = ['a','b','c','d','e','f','g','h'];
    const wrapper = document.getElementById('chessboard-wrapper');
    const squareSize = document.querySelector('.square').offsetWidth;
    
    // Create column labels along the bottom (files a-h left-to-right)
    for (let i = 0; i < 8; i++) {
        const label = document.createElement('div');
        label.classList.add('outside-label', 'column-label');
        label.textContent = files[i];
        // Position centered both horizontally and vertically
        label.style.left = `${25 + i * squareSize + squareSize/2 - 8}px`; // Center horizontally
        label.style.bottom = '2px'; // Align closer to the board
        wrapper.appendChild(label);
    }
    
    // Create row labels along the left (ranks 1-8 bottom-to-top)
    for (let i = 0; i < 8; i++) {
        const label = document.createElement('div');
        label.classList.add('outside-label', 'row-label');
        label.textContent = (8 - i).toString(); // 8 at top (i=0), 1 at bottom (i=7)
        label.style.left = '5px';
        // Position centered vertically relative to the square
        label.style.top = `${25 + i * squareSize + squareSize/2 - 8}px`; // Center vertically
        wrapper.appendChild(label);
    }
}

    function updateGridButtonText() {
        const btn = document.getElementById('toggle-grid-btn');
        btn.textContent = (gridLabelMode === 0) ? "Hide Grid Labels" : "Show Grid Labels";
    }

    function toggleGridLabels() {
        gridLabelMode = (gridLabelMode === 0) ? 3 : 0;
        createOutsideLabels();
        updateBoard();
        updateGridButtonText();
    }

    /* Fix PC click handling for valid move highlighting */
    function handleSquareClick(index) {
        const row = Math.floor(index / 8);
        const col = index % 8;
        const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        if (gameState.selection === 100) {
            if ((gameState.turn_step % 2 === 0 && whiteIndex !== -1) || 
                (gameState.turn_step % 2 === 1 && blackIndex !== -1)) {
                clearValidMoves();
                const piece_index = gameState.turn_step % 2 === 0 ? whiteIndex : blackIndex;
                gameState.selection = piece_index;
                gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                    gameState.white_options[piece_index] : 
                    gameState.black_options[piece_index];
                updateBoard();
                highlightValidMoves(); // Add this line to ensure valid moves are highlighted
            }
        } else {
            const move = [col, row];
            const validMove = gameState.valid_moves.some(vm => {
                if (Array.isArray(vm)) {
                    return vm[0] === col && vm[1] === row;
                }
                return false;
            });
            if (validMove) {
                clearValidMoves();
                makeMove(gameState.selection, move);
            } else {
                clearValidMoves();
                gameState.selection = 100;
                gameState.valid_moves = [];
                updateBoard();
            }
        }
    }

    function handlePromotion(color, index) {
        promoColor = color;
        promoIndex = index;
        promotionOptions.innerHTML = '';
        let selectedPiece = null;
        const pieces = ['queen', 'rook', 'bishop', 'knight'];
        const piecePrefix = color === 'white' ? 'lt' : 'dt';
        pieces.forEach(piece => {
            const option = document.createElement('div');
            option.classList.add('promotion-option');
            const img = document.createElement('img');
            img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}${piecePrefix}60.png`;
            option.appendChild(img);
            option.addEventListener('click', () => {
                if (selectedPiece === piece) {
                    selectPromotion(piece);
                } else {
                    selectedPiece = piece;
                    promotionOptions.querySelectorAll('.promotion-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');
                    selectedPiece = piece;
                }
            });
            promotionOptions.appendChild(option);
        });
        document.addEventListener('click', function closeModal(e) {
            if (!promotionModal.contains(e.target) && selectedPiece) {
                promotionModal.style.display = 'none';
                document.removeEventListener('click', closeModal);
            }
        });
        promotionModal.style.display = 'block';
    }

    function selectPromotion(piece) {
        fetch('/promote', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                color: promoColor,
                piece: piece,
                index: promoIndex
            })
        })
        .then(response => response.json())
        .then(data => {
            Object.assign(gameState, data);
            promotionModal.style.display = 'none';
            updateBoard();
        })
        .catch(error => {
            console.error('Error promoting pawn:', error);
        });
    }

// Update the updateBoard function to fix inside grid labels
function updateBoard() {
    const squares = document.querySelectorAll('.square');
    squares.forEach(square => {
        square.innerHTML = '';
        square.classList.remove('last-move-from', 'last-move-to', 'valid-move', 'castle-move');
    });
    const outsideLabels = document.querySelectorAll('.outside-label');
    outsideLabels.forEach(label => {
        label.style.display = (gridLabelMode === 0 || gridLabelMode === 1) ? 'block' : 'none';
    });
    squares.forEach(square => {
        const index = parseInt(square.dataset.index);
        let row = Math.floor(index / 8);
        let col = index % 8;

        const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        if (whiteIndex !== -1) {
            const piece = gameState.white_pieces[whiteIndex];
            if (piece) {
                const img = document.createElement('img');
                img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}lt60.png`;
                img.classList.add('piece-image');
                img.draggable = true;
                img.dataset.pieceIndex = whiteIndex;
                img.dataset.pieceColor = 'white';
                img.addEventListener('dragstart', (e) => handleDragStart(e, whiteIndex, 'white'));
                square.appendChild(img);
            }
        } else if (blackIndex !== -1) {
            const piece = gameState.black_pieces[blackIndex];
            if (piece) {
                const img = document.createElement('img');
                img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}dt60.png`;
                img.classList.add('piece-image');
                img.draggable = true;
                img.dataset.pieceIndex = blackIndex;
                img.dataset.pieceColor = 'black';
                img.addEventListener('dragstart', (e) => handleDragStart(e, blackIndex, 'black'));
                square.appendChild(img);
            }
        }
        if (gameState.last_move) {
            const [fromCol, fromRow] = gameState.last_move.from;
            const [toCol, toRow] = gameState.last_move.to;
            if (col === fromCol && row === fromRow) { square.classList.add('last-move-from'); }
            if (col === toCol && row === toRow) { square.classList.add('last-move-to'); }
        }
    });
    if (gameState.valid_moves) {
        gameState.valid_moves.forEach(move => {
            if (Array.isArray(move) && move.length >= 2) {
                const [col, row] = move;
                const index = row * 8 + col;
                const square = document.querySelector(`.square[data-index="${index}"]`);
                if (square) {
                    square.classList.add('valid-move');
                    if (move.length > 2 && typeof move[2] === 'string' && move[2].includes('castle')) {
                        square.classList.add('castle-move');
                    }
                }
            }
        });
    }
    if (gameState.last_move) {
        setTimeout(() => {
            drawMoveArrow(gameState.last_move.from, gameState.last_move.to);
            console.log("Drawing arrow from", gameState.last_move.from, "to", gameState.last_move.to);
        }, 100);
    } else { clearMoveArrow(); }
    updateCapturedPieces(capturedWhite, gameState.captured_pieces_white, 'white');
    updateCapturedPieces(capturedBlack, gameState.captured_pieces_black, 'black');
    const turnColor = gameState.turn_step % 2 === 0 ? 'WHITE' : 'BLACK';
    if (playingVsAI) {
        const playerTurnText = gameState.turn_step % 2 === 0 ? 'WHITE (You)' : 'BLACK (AI)';
        const difficulty = gameState.difficulty || 'Easy';
        const displayDifficulty = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
        turnDisplay.textContent = `Current Turn: ${playerTurnText} - Playing vs AI (${displayDifficulty})`;
    } else { turnDisplay.textContent = `Current Turn: ${turnColor}`; }
    if (gameState.game_over) {
        checkDisplay.textContent = `${gameState.winner.toUpperCase()} WINS BY CAPTURING THE KING!`;
        checkDisplay.className = 'check-indicator checkmate-notification';
        board.style.pointerEvents = 'none';
    } else if (gameState.checkmate) {
        const inCheck = gameState.check.toUpperCase();
        checkDisplay.textContent = `CHECKMATE! ${inCheck} king can be captured!`;
        checkDisplay.className = 'check-indicator checkmate-notification';
    } else if (gameState.check) {
        checkDisplay.textContent = `${gameState.check.toUpperCase()} IS IN CHECK!`;
        checkDisplay.className = 'check-indicator check-notification';
    } else {
        checkDisplay.textContent = '';
        checkDisplay.className = 'check-indicator';
    }
}

    function updateCapturedPieces(container, capturedPieces, opponentColor) {
        container.innerHTML = '';
        
        if (!capturedPieces || capturedPieces.length === 0) {
            return;
        }
        
        const pieceCount = {};
        capturedPieces.forEach(piece => {
            if (!pieceCount[piece]) {
                pieceCount[piece]++;
            }
            pieceCount[piece]++;
        });
        
        Object.keys(pieceCount).forEach(piece => {
            const pieceGroup = document.createElement('div');
            pieceGroup.style.display = 'inline-flex';
            pieceGroup.style.alignItems = 'center';
            pieceGroup.style.margin = '0 5px';
            
            const img = document.createElement('img');
            const colorPrefix = opponentColor === 'white' ? 'lt' : 'dt';
            img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}${colorPrefix}60.png`;
            img.className = 'captured-piece';
            pieceGroup.appendChild(img);
            
            if (pieceCount[piece] > 1) {
                const count = document.createElement('span');
                count.textContent = `Ã—${pieceCount[piece]}`;
                count.style.fontSize = '14px';
                count.style.margin = '0 3px';
                pieceGroup.appendChild(count);
            }
            
            container.appendChild(pieceGroup);
        });
    }

    function drawMoveArrow(from, to) {
        const arrowContainer = document.getElementById('move-arrow');
        const svg = arrowContainer.querySelector('svg');
        const squareSize = document.querySelector('.square').offsetWidth;
        const wrapper = document.getElementById('chessboard-wrapper');
        
        if (!from || !to || from.length < 2) {
            console.error("Invalid move coordinates:", from, to);
            return;
        }
        
        const fromCol = Number(from[0]);
        const fromRow = Number(from[1]);
        const toCol = Number(to[0]);
        const toRow = Number(to[1]);
        
        arrowContainer.style.position = 'absolute';
        arrowContainer.style.left = '0';
        arrowContainer.style.top = '0';
        arrowContainer.style.width = '100%';
        arrowContainer.style.height = '100%';
        arrowContainer.style.pointerEvents = 'none';
        arrowContainer.style.zIndex = '5';
        
        svg.setAttribute('width', wrapper.offsetWidth);
        svg.setAttribute('height', wrapper.offsetHeight);
        
        const padding = 25;
        const startX = padding + fromCol * squareSize + squareSize / 2;
        const startY = padding + fromRow * squareSize + squareSize / 2;
        const endX = padding + toCol * squareSize + squareSize / 2;
        const endY = padding + toRow * squareSize + squareSize / 2;
        
        const dx = endX - startX;
        const dy = endY - startY;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length === 0) {
            svg.innerHTML = '';
            return;
        }
        
        const unitX = dx / length;
        const unitY = dy / length;
        
        const shortenAmount = squareSize * 0.4; 
        const newStartX = startX + unitX * shortenAmount;
        const newStartY = startY + unitY * shortenAmount;
        const newEndX = endX - unitX * shortenAmount;
        const newEndY = endY - unitY * shortenAmount;
        
        const strokeWidth = Math.max(2, squareSize / 20);
        
        svg.innerHTML = `
            <defs>
                <marker id="arrowhead" 
                       viewBox="0 0 10 10"
                       refX="1"
                       refY="5"
                       markerWidth="4"
                       markerHeight="4"
                       orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#ffaa00" fill-opacity="0.5"/>
                </marker>
            </defs>
            <line 
                x1="${newStartX}"
                y1="${newStartY}"
                x2="${newEndX}"
                y2="${newEndY}"
                stroke="#ffaa00"
                stroke-width="${strokeWidth}"
                marker-end="url(#arrowhead)"
                stroke-opacity="0.5" />
        `;
    }

    function clearMoveArrow() {
        const arrowContainer = document.getElementById('move-arrow');
        const svg = arrowContainer.querySelector('svg');
        svg.innerHTML = '';
    }

    window.addEventListener('resize', () => {
        if (gameState && gameState.last_move) {
            setTimeout(() => {
                drawMoveArrow(gameState.last_move.from, gameState.last_move.to);
                createOutsideLabels();
            }, 100);
        }
    });

// Update the restartGame function to include the current difficulty
function restartGame() {
    board.style.pointerEvents = 'auto';
    
    // Create the restart data with the current difficulty if playing against AI
    const restartData = { 
        vsAI: playingVsAI, 
        aiColor: 'black'
    };
    
    // Preserve the current difficulty setting when restarting
    if (playingVsAI && gameState && gameState.difficulty) {
        restartData.difficulty = gameState.difficulty;
    }
    
    fetch('/restart', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(restartData)
    })
    .then(response => response.json())
    .then(data => {
        console.log("Restart data received:", data);
        gameState = data;
        if (!Array.isArray(gameState.valid_moves)) {
            gameState.valid_moves = [];
        }
        gameState.selection = 100;
        clearMoveArrow();
        updateBoard();
    })
    .catch(error => {
        console.error('Error restarting game:', error);
    });
}

    function toggleSound() {
        if (backgroundMusic.muted) {
            backgroundMusic.muted = false;
            soundIcon.src = '/static/sound-on.png';
            backgroundMusic.play();
        } else {
            backgroundMusic.muted = true;
            soundIcon.src = '/static/sound-off.png';
        }
    }

    function handleDragStart(e, pieceIndex, color) {
        // Skip if not this player's turn
        if (!((gameState.turn_step % 2 === 0 && color === 'white') || 
              (gameState.turn_step % 2 === 1 && color === 'black'))) {
            e.preventDefault();
            return;
        }

        // Set up the drag operation
        draggedPiece = e.target;
        draggedPieceIndex = pieceIndex;
        
        // Set dataTransfer properties for desktop drag
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', pieceIndex);
        
        // Update game state and show valid moves
        gameState.selection = pieceIndex;
        gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
            gameState.white_options[pieceIndex] : 
            gameState.black_options[pieceIndex];
        
        // Highlight valid moves
        clearValidMoves(); // Clear any existing highlights first
        
        // Find castle moves for special highlighting
        const castleMoves = gameState.valid_moves.filter(vm => 
            Array.isArray(vm) && vm.length > 2 && 
            typeof vm[2] === 'string' && vm[2].includes('castle')
        );
        
        // Mark valid drop targets
        validDropTargets = gameState.valid_moves.map(move => {
            const [col, row] = Array.isArray(move) ? move.slice(0, 2) : move;
            return row * 8 + col;
        });
        
        validDropTargets.forEach(index => {
            const square = document.querySelector(`.square[data-index="${index}"]`);
            if (square) {
                square.classList.add('valid-drop-target');
                
                const row = Math.floor(index / 8);
                const col = index % 8;
                const isCastleMove = castleMoves.some(move => 
                    move[0] === col && move[1] === row
                );
                
                if (isCastleMove) {
                    square.classList.add('castle-move');
                }
            }
        });
        
        // Add the dragging class after a short delay
        setTimeout(() => {
            if (draggedPiece) {
                draggedPiece.classList.add('dragging');
            }
        }, 0);
        
        // Add cleanup on drag end
        draggedPiece.addEventListener('dragend', cleanupDrag, { once: true });
    }

    function cleanupDrag() {
        // Clear all valid move highlighting
        validDropTargets.forEach(index => {
            const square = document.querySelector(`.square[data-index="${index}"]`);
            if (square) {
                square.classList.remove('valid-drop-target');
                square.classList.remove('castle-move');
                square.classList.remove('drag-over');
            }
        });
        
        // Remove dragging class from the piece
        if (draggedPiece) {
            draggedPiece.classList.remove('dragging');
        }
        
        // Reset drag state variables
        draggedPiece = null;
        draggedPieceIndex = -1;
        validDropTargets = [];
    }

    function handleDragOver(e, index) {
        if (validDropTargets.includes(index)) {
            e.preventDefault();
        }
    }

    function handleDragEnter(e, index) {
        if (validDropTargets.includes(index)) {
            e.currentTarget.classList.add('drag-over');
        }
    }

    function handleDragLeave(e) {
        e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e, index) {
        e.currentTarget.classList.remove('drag-over');
        if (validDropTargets.includes(index)) {
            e.preventDefault();
            makeMove(draggedPieceIndex, [index % 8, Math.floor(index / 8)]);
        }
    }

    function makeMove(pieceIndex, move) {
        const currentPos = gameState.turn_step % 2 === 0 
            ? gameState.white_locations[pieceIndex] 
            : gameState.black_locations[pieceIndex];
        
        const moveData = {
            piece_index: pieceIndex,
            move: move,
            from: currentPos,
            vs_ai: playingVsAI
        };

        fetch('/move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(moveData)
        })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            if (gameState.promotion) {
                handlePromotion(gameState.promotion.color, gameState.promotion.index);
            } else {
                updateBoard();
                if (playingVsAI && !gameState.game_over && gameState.turn_step % 2 === 1) {
                    console.log("Requesting AI move...");
                    setTimeout(() => {
                        requestAIMove();
                    }, 500);
                }
            }
        })
        .catch(error => console.error('Error:', error));
    }

    function requestAIMove() {
        turnDisplay.textContent = "AI is thinking...";
        
        fetch('/ai_move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                game_state: gameState
            })
        })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            if (gameState.promotion) {
                fetch('/promote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        color: gameState.promotion.color,
                        piece: 'queen',
                        index: gameState.promotion.index
                    })
                })
                .then(response => response.json())
                .then(promotionData => {
                    Object.assign(gameState, promotionData);
                    updateBoard();
                });
            } else {
                updateBoard();
            }
        })
        .catch(error => {
            console.error('Error getting AI move:', error);
            turnDisplay.textContent = `Current Turn: BLACK (AI)`;
        });
    }

// Fix the playVsAI function to properly initialize the chess_ai variable
function playVsAI() {
    if (!playingVsAI) {
        playingVsAI = true;

        // Hide main AI button and create difficulty buttons
        document.getElementById('ai-btn').style.display = 'none';
        let aiContainer = document.createElement('div');
        aiContainer.id = 'ai-difficulty-container';

        let pvpButton = document.createElement('button');
        pvpButton.textContent = 'PvP';
        pvpButton.onclick = function () {
            playingVsAI = false;
            removeDifficultyButtons();
            document.getElementById('ai-btn').style.display = 'block';
            // Restart in PvP mode
            fetch('/restart', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ vsAI: false })
            }).then(response => response.json())
                .then(data => {
                    gameState = data;
                    updateBoard();
                });
        };

        let easyBtn = document.createElement('button');
        easyBtn.textContent = 'Easy';
        easyBtn.onclick = function () { setAIDifficulty('easy'); };

        let mediumBtn = document.createElement('button');
        mediumBtn.textContent = 'Medium';
        mediumBtn.onclick = function () { setAIDifficulty('medium'); };

        let hardBtn = document.createElement('button');
        hardBtn.textContent = 'Hard';
        hardBtn.onclick = function () { setAIDifficulty('hard'); };

        aiContainer.appendChild(pvpButton);
        aiContainer.appendChild(easyBtn);
        aiContainer.appendChild(mediumBtn);
        aiContainer.appendChild(hardBtn);

        // Insert above the Toggle Grid Labels button
        let container = document.querySelector('.button-container');
        let gridBtn = document.getElementById('toggle-grid-btn');
        container.insertBefore(aiContainer, gridBtn);

        // Immediately start game with Easy difficulty
        setAIDifficulty('easy');
    }
}

function removeDifficultyButtons() {
    let aiContainer = document.getElementById('ai-difficulty-container');
    if (aiContainer) aiContainer.remove();
}

// Fix the setAIDifficulty function to not reference the undefined chess_ai
function setAIDifficulty(difficulty) {
    fetch('/restart', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ vsAI: true, aiColor: 'black', difficulty: difficulty })
    })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            updateBoard();
            let displayDifficulty = difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
            turnDisplay.textContent = `Current Turn: WHITE (You) - Playing vs AI (${displayDifficulty})`;
        });
}

    window.onload = () => {
        const gameInfo = document.getElementById('game-info');
        const buttonContainer = document.querySelector('.button-container');
        const capturedInfo = document.getElementById('captured-white').parentElement;
        document.body.style.display = 'flex';
        document.body.style.flexDirection = 'column';
        document.body.style.alignItems = 'center';
        createBoard();
        fetch('/state', { method: 'GET' })
            .then(response => response.json())
            .then(data => {
                gameState = data;
                updateBoard();
                backgroundMusic.muted = true;
                soundIcon.src = '/static/sound-off.png';
            })
            .catch(error => {
                console.error('Error fetching game state:', error);
            });
    };

    /* Add a new function to highlight valid moves */
    function highlightValidMoves() {
        if (!gameState.valid_moves) {
            console.log("No valid moves to highlight");
            return;
        }
        
        // Log valid moves for debugging
        console.log("Highlighting valid moves:", gameState.valid_moves);
        
        // Clear any existing highlights first to ensure clean state
        document.querySelectorAll('.square.valid-move').forEach(square => {
            square.classList.remove('valid-move');
        });
        document.querySelectorAll('.square.castle-move').forEach(square => {
            square.classList.remove('castle-move');
        });
        document.querySelectorAll('.square.selected-square').forEach(square => {
            square.classList.remove('selected-square');
        });
        
        // Highlight the selected piece's square
        if (gameState.selection !== 100) {
            const color = gameState.turn_step % 2 === 0 ? 'white' : 'black';
            const position = color === 'white' ? 
                gameState.white_locations[gameState.selection] : 
                gameState.black_locations[gameState.selection];
            
            if (position && Array.isArray(position) && position.length === 2) {
                const [col, row] = position;
                const squareIndex = row * 8 + col;
                const selectedSquare = document.querySelector(`.square[data-index="${squareIndex}"]`);
                if (selectedSquare) {
                    selectedSquare.classList.add('selected-square');
                }
            }
        }
        
        // Now apply the highlights for valid moves
        gameState.valid_moves.forEach(move => {
            if (Array.isArray(move) && move.length >= 2) {
                const [col, row] = move;
                const index = row * 8 + col;
                const square = document.querySelector(`.square[data-index="${index}"]`);
                
                if (square) {
                    square.classList.add('valid-move');
                    
                    if (move.length > 2 && typeof move[2] === 'string' && move[2].includes('castle')) {
                        square.classList.add('castle-move');
                    }
                    
                    console.log(`Highlighted square at ${col},${row} (index ${index})`);
                } else {
                    console.log(`Could not find square at ${col},${row} (index ${index})`);
                }
            }
        });
    }

    /* Make sure the clearValidMoves function properly removes all highlighting classes */
    function clearValidMoves() {
        document.querySelectorAll('.square.valid-move').forEach(square => {
            square.classList.remove('valid-move');
        });
        document.querySelectorAll('.square.castle-move').forEach(square => {
            square.classList.remove('castle-move');
        });
        document.querySelectorAll('.square.valid-drop-target').forEach(square => {
            square.classList.remove('valid-drop-target');
        });
        document.querySelectorAll('.square.drag-over').forEach(square => {
            square.classList.remove('drag-over');
        });
        document.querySelectorAll('.square.selected-square').forEach(square => {
            square.classList.remove('selected-square');
        });
    }

    /* Add touch event handlers for mobile devices */

    function handleTouchStart(e, pieceIndex, color) {
        // Only proceed if it's this player's turn
        if (!((gameState.turn_step % 2 === 0 && color === 'white') || 
              (gameState.turn_step % 2 === 1 && color === 'black'))) {
            return;
        }

        // Prevent default to avoid any browser handling that might interfere
        e.preventDefault();
        e.stopPropagation();
        
        // Store the initial touch position to determine if this was a tap or drag
        const touch = e.touches[0];
        const startX = touch.clientX;
        const startY = touch.clientY;
        
        // Clear any existing drag state
        cleanupTouch();
        
        // Set up game state
        gameState.selection = pieceIndex;
        gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
            gameState.white_options[pieceIndex] : 
            gameState.black_options[pieceIndex];
        
        // Track the time to differentiate between tap and drag
        const startTime = Date.now();
        
        // Set touch information
        const target = e.target;
        draggedPiece = target;
        draggedPieceIndex = pieceIndex;
        
        // Track if we've moved enough to consider this a drag
        let isDragging = false;
        let dragClone = null;
        
        // Handle the move event
        function handleMove(moveEvent) {
            moveEvent.preventDefault();
            moveEvent.stopPropagation();
            
            const moveTouch = moveEvent.touches[0];
            const moveX = moveTouch.clientX;
            const moveY = moveTouch.clientY;
            
            // Calculate distance moved
            const distX = moveX - startX;
            const distY = moveY - startY;
            const distance = Math.sqrt(distX * distX + distY * distY);
            
            // If moved more than threshold, initiate drag
            if (distance > 10 && !isDragging) {
                isDragging = true;
                
                // Create draggable element for drag operation
                dragClone = document.createElement('img');
                dragClone.src = target.src;
                dragClone.classList.add('piece-dragging');
                document.body.appendChild(dragClone);
                
                // Set up valid drop targets
                validDropTargets = gameState.valid_moves.map(move => {
                    const [col, row] = Array.isArray(move) ? move.slice(0, 2) : move;
                    return row * 8 + col;
                });
                
                // Highlight valid targets
                validDropTargets.forEach(index => {
                    const square = document.querySelector(`.square[data-index="${index}"]`);
                    if (square) {
                        square.classList.add('valid-drop-target');
                        
                        // Check for castle move
                        const row = Math.floor(index / 8);
                        const col = index % 8;
                        const isCastleMove = gameState.valid_moves.some(move => {
                            return Array.isArray(move) && move.length > 2 && 
                                   move[0] === col && move[1] === row && 
                                   typeof move[2] === 'string' && move[2].includes('castle');
                        });
                        
                        if (isCastleMove) {
                            square.classList.add('castle-move');
                        }
                    }
                });
                
                // Add dragging class to body
                document.body.classList.add('dragging');
            }
            
            // If dragging, update the clone's position
            if (isDragging && dragClone) {
                requestAnimationFrame(() => {
                    positionCloneAtTouch(dragClone, moveX, moveY);
                });
                
                // Find square under finger
                const elementsAtTouch = document.elementsFromPoint(moveX, moveY);
                const squareUnderTouch = elementsAtTouch.find(el => el.classList.contains('square'));
                
                // Clear previous highlights
                document.querySelectorAll('.square.drag-over').forEach(sq => {
                    if (sq !== squareUnderTouch) {
                        sq.classList.remove('drag-over');
                    }
                });
                
                // Highlight current valid target
                if (squareUnderTouch) {
                    const squareIndex = parseInt(squareUnderTouch.dataset.index);
                    if (validDropTargets.includes(squareIndex)) {
                        squareUnderTouch.classList.add('drag-over');
                    }
                }
            }
        }
        
        // Handle the touch end event
        function handleEnd(endEvent) {
            endEvent.preventDefault();
            
            // Remove all event listeners
            document.removeEventListener('touchmove', handleMove);
            document.removeEventListener('touchend', handleEnd);
            
            // Handle a tap (quick touch without much movement)
            if (!isDragging) {
                // If it was a short tap (less than 300ms), treat as click/tap
                if (Date.now() - startTime < 300) {
                    // Update the board and highlight valid moves
                    updateBoard();
                    highlightValidMoves();
                }
                return;
            }
            
            // Handle end of drag if we were dragging
            if (isDragging) {
                const touch = endEvent.changedTouches[0];
                
                // Find the square under the finger
                const elementsAtTouch = document.elementsFromPoint(touch.clientX, touch.clientY);
                const squareUnderTouch = elementsAtTouch.find(el => el.classList.contains('square'));
                
                // Make move if it's a valid target
                if (squareUnderTouch) {
                    const squareIndex = parseInt(squareUnderTouch.dataset.index);
                    if (validDropTargets.includes(squareIndex)) {
                        const col = squareIndex % 8;
                        const row = Math.floor(squareIndex / 8);
                        makeMove(draggedPieceIndex, [col, row]);
                    }
                }
            }
            
            // Clean up
            cleanupTouch();
        }
        
        // Set up the event listeners for move and end
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', handleEnd, { passive: false });
        document.addEventListener('touchcancel', cleanupTouch);
    }

    // Improved positioning function that works reliably on mobile
    function positionCloneAtTouch(element, x, y) {
        const size = (window.innerWidth <= 768) ? 20 : 35; // Half width for mobile/desktop
        element.style.left = `${x - size}px`;
        element.style.top = `${y - size}px`;
    }

    function handleTouchMove(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggedPiece) return;
        
        const touch = e.touches[0];
        const clone = document.querySelector('.piece-dragging');
        
        if (clone) {
            // Use requestAnimationFrame for smoother updates
            requestAnimationFrame(() => {
                positionCloneAtTouch(clone, touch.clientX, touch.clientY);
            });
            
            // Find square under finger
            const elementsAtTouch = document.elementsFromPoint(touch.clientX, touch.clientY);
            const squareUnderTouch = elementsAtTouch.find(el => el.classList.contains('square'));
            
            // Clear previous highlights
            document.querySelectorAll('.square.drag-over').forEach(sq => {
                if (sq !== squareUnderTouch) {
                    sq.classList.remove('drag-over');
                }
            });
            
            // Highlight current valid target
            if (squareUnderTouch) {
                const squareIndex = parseInt(squareUnderTouch.dataset.index);
                if (validDropTargets.includes(squareIndex)) {
                    squareUnderTouch.classList.add('drag-over');
                }
            }
        }
    }

    function handleTouchEnd(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!draggedPiece) return;
        
        // Find the square under the finger
        const touch = e.changedTouches[0];
        const elementsAtTouch = document.elementsFromPoint(touch.clientX, touch.clientY);
        const squareUnderTouch = elementsAtTouch.find(el => el.classList.contains('square'));
        
        // Make move if it's a valid target
        if (squareUnderTouch) {
            const squareIndex = parseInt(squareUnderTouch.dataset.index);
            if (validDropTargets.includes(squareIndex)) {
                const col = squareIndex % 8;
                const row = Math.floor(squareIndex / 8);
                makeMove(draggedPieceIndex, [col, row]);
            }
        }
        
        cleanupTouch();
    }

    function cleanupTouch() {
        // Remove dragged clone
        document.querySelectorAll('.piece-dragging').forEach(clone => clone.remove());
        
        // Clear highlighting
        document.querySelectorAll('.square.valid-drop-target').forEach(square => {
            square.classList.remove('valid-drop-target');
        });
        document.querySelectorAll('.square.castle-move').forEach(square => {
            square.classList.remove('castle-move');
        });
        document.querySelectorAll('.square.drag-over').forEach(square => {
            square.classList.remove('drag-over');
        });
        
        // Remove event listeners
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
        document.removeEventListener('touchcancel', cleanupTouch);
        
        // Reset state
        document.body.classList.remove('dragging');
        draggedPiece = null;
        draggedPieceIndex = -1;
        validDropTargets = [];
    }

    // Replace the updateBoard function's touch event binding section:
    let originalUpdateBoard = updateBoard;
    updateBoard = function() {
        originalUpdateBoard();
        
        // Clean up any leftover drag pieces
        document.querySelectorAll('.piece-dragging').forEach(el => el.remove());
        
        // Add touch AND mouse events to all pieces
        document.querySelectorAll('.piece-image').forEach(img => {
            const pieceIndex = parseInt(img.dataset.pieceIndex);
            const pieceColor = img.dataset.pieceColor;
            
            // Replace with new element to ensure clean event listeners
            const newImg = img.cloneNode(true);
            img.parentNode.replaceChild(newImg, img);
            
            // Add touch event with non-passive flag to prevent scrolling
            newImg.addEventListener('touchstart', function(e) {
                handleTouchStart(e, pieceIndex, pieceColor);
            }, { passive: false });
            
            // Add desktop drag support 
            newImg.draggable = true;
            newImg.addEventListener('dragstart', function(e) {
                handleDragStart(e, pieceIndex, pieceColor);
            });
            
            // Remove the click event here so the square's own click handler (bound in createBoard) manages PC clicks.
        });
    };

    /* Add global error handlers to ensure cleanup */
    window.addEventListener('touchcancel', cleanupTouch);
    window.addEventListener('blur', cleanupTouch);
    window.addEventListener('error', cleanupTouch);
    window.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        return false;
    });

    // Add additional CSS to make mobile pieces easier to interact with
    const styleSheet = document.createElement('style');
    styleSheet.innerHTML = `
    @media (max-width: 768px) {
        .square {
            touch-action: none !important;
        }
        .piece-image {
            touch-action: none !important;
            -webkit-user-select: none;
            user-select: none;
        }
        .piece-dragging {
            will-change: left, top;
            pointer-events: none !important;
            position: fixed !important;
            z-index: 2000;
        }
    }`;
    document.head.appendChild(styleSheet);

    // Also add CSS improvements for outside labels to center them better
    const styleSheet2 = document.createElement('style');
    styleSheet2.innerHTML = `
    .outside-label {
        position: absolute;
        font-size: 16px;
        color: rgba(180, 180, 180, 0.9);
        text-align: center;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .column-label { 
        width: 20px;  /* Reduced width for better centering */
    }
    .row-label { 
        width: 20px;
        height: 20px; /* Fixed height for better vertical centering */
        line-height: 1;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    /* ...existing styles... */
    `;
    document.head.appendChild(styleSheet2);

// Add CSS improvements for button heights
const styleSheet3 = document.createElement('style');
styleSheet3.innerHTML = `
    #ai-difficulty-container button {
        height: 40px; /* Match the height of the Play vs AI button */
    }
    #ai-difficulty-container {
        margin-bottom: 0; /* Remove the bottom margin to avoid shifting */
    }
`;
document.head.appendChild(styleSheet3);
    </script>
</body>
</html>

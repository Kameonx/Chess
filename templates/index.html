<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: white;
        }
        
        #game-info {
            margin: 20px 0;
            font-size: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        
        #turn-display {
            margin-bottom: 5px;
        }
        
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            touch-action: zoom-in;
            position: relative;
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        
        .white { background-color: #f0d9b5; }
        .black { background-color: #b58863; }
        
        #captured-white, #captured-black {
            margin: 10px 0;
            font-size: 20px;
        }
        
        .piece-image {
            max-width: 80px;
            max-height: 80px;
            user-select: none; /* Prevent text selection during drag */
        }
        
        .valid-move {
            background-color: rgba(0, 255, 0, 0.5);
        }
        
        .castle-move {
            background-color: rgba(0, 0, 255, 0.5) !important; /* Add !important to ensure it takes precedence */
        }
        
        #restart-btn {
            padding: 10px 20px;
            font-size: 18px;
            margin: 10px 0;
            cursor: pointer;
        }
        
        .check-indicator {
            font-weight: bold;
        }

        .check-notification {
            color: yellow; /* Change this to your desired color for check */
        }
        
        .checkmate-notification {
            color: #ff0000;
            font-weight: bold;
            font-size: 28px; /* Make it larger */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); /* Add shadow for emphasis */
        }
        
        #promotion-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            text-align: center;
        }

        .promotion-option {
            display: inline-block;
            cursor: pointer;
            margin: 10px;
            padding: 10px;
            border-radius: 5px;
            background-color: #3a3a3a;
            transition: background-color 0.3s;
        }

        .promotion-option:hover {
            background-color: #4a4a4a;
        }

        .promotion-option img {
            width: 60px;
            height: 60px;
        }
        
        .grid-label {
            position: absolute;
            font-size: 14px;
            color: rgba(180, 180, 180, 0.9); /* Darker text */
        }
        
        .grid-label.top-left {
            top: 2px;
            left: 2px;
        }
        
        .grid-label.bottom-right {
            bottom: 2px;
            right: 2px;
        }
        
        #chessboard-wrapper {
            position: relative;
            padding: 25px;
            margin-bottom: 10px;
        }
        
        .outside-label {
            position: absolute;
            font-size: 16px;
            color: rgba(180, 180, 180, 0.9);
            text-align: center;
        }
        
        .column-label {
            width: 100px;
            height: 20px;
        }
        
        .row-label {
            width: 20px;
            height: 100px;
            line-height: 100px;
        }
        
        .button-row {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        #restart-btn, #toggle-grid-btn {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
        
        @media (max-width: 600px) {
            #chessboard-wrapper {
                padding: 20px;
            }
            
            .column-label {
                width: 50px;
            }
            
            .row-label {
                height: 50px;
                line-height: 50px;
            }
        }
        
        .promotion-option.selected {
            background-color: #5a5a5a;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .promotion-option {
            transition: all 0.3s ease;
        }
        
        .piece-dragging {
            opacity: 0.6;
            cursor: grabbing;
            pointer-events: none;
            position: absolute;
            z-index: 1000;
            transform: translate(-50%, -50%);
        }
        
        .square.drag-over {
            box-shadow: inset 0 0 10px #ffff00;
        }
        
        .square.valid-drop-target {
            background-color: rgba(0, 255, 0, 0.3);
        }
        
        .square.valid-drop-target.castle-move {
            background-color: rgba(0, 0, 255, 0.5) !important;
        }
        
        .last-move-from {
            box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.5);
        }
        
        .last-move-to {
            box-shadow: inset 0 0 0 4px rgba(255, 165, 0, 0.7);
        }
        
        #move-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }
        
        #move-arrow svg {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        @media (max-width: 600px) {
            #move-arrow {
                transform: scale(0.5);
                transform-origin: top left;
            }
        }

        /* Positioning the buttons vertically with consistent size */
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            width: 200px;
            order: 3; /* Move to the end of the flex container */
        }
        
        #restart-btn, #toggle-grid-btn {
            padding: 10px 0;
            font-size: 18px;
            cursor: pointer;
            width: 100%;
            margin: 0;
        }
        
        /* Sound icon centered at bottom */
        #sound-icon {
            position: fixed;
            bottom: 20px;
            right: 20px;
            cursor: pointer;
            width: 24px;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            padding: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        #sound-icon img {
            width: 100%;
            height: 100%;
        }

        /* Remove turn choice button styles */
    </style>
</head>
<body>
    <div id="game-info">
        <div id="turn-display"></div>
        <!-- Removed turn-choice-button -->
        <div id="check-display" class="check-indicator"></div>
    </div>
    
    <div id="chessboard"></div>
    <div id="move-arrow"><svg></svg></div>
    <div id="captured-white">Captured White: <span id="captured-white-list"></span></div>
    <div id="captured-black">Captured Black: <span id="captured-black-list"></span></div>
    
    <!-- Button container moved to bottom -->
    <div class="button-container">
        <button id="restart-btn" onclick="restartGame()">Restart Game</button>
        <button id="toggle-grid-btn" onclick="toggleGridLabels()">Grid Labels</button>
    </div>
    
    <div id="promotion-modal">
        <div style="color: white; margin-bottom: 15px; font-size: 20px;">Choose promotion piece:</div>
        <div id="promotion-options"></div>
    </div>
    <audio id="background-music" src="/audio/Chess Type Beat _ joyful - chess (slowed).mp3" loop muted></audio>
    <div id="sound-icon" onclick="toggleSound()">
        <img src="/static/sound-off.png" alt="Sound Off">
    </div>
    <script>
    const board = document.getElementById('chessboard');
    const capturedWhite = document.getElementById('captured-white-list');
    const capturedBlack = document.getElementById('captured-black-list');
    const restartBtn = document.getElementById('restart-btn');
    const turnDisplay = document.getElementById('turn-display');
    const checkDisplay = document.getElementById('check-display');
    const promotionModal = document.getElementById('promotion-modal');
    const promotionOptions = document.getElementById('promotion-options');
    const backgroundMusic = document.getElementById('background-music');
    const soundIcon = document.getElementById('sound-icon').querySelector('img');
    // Remove turnChoiceBtn and nextGameTurn variables
    let draggedPiece = null;
    let draggedPieceIndex = -1;
    let draggedPieceOffsetX = 0;
    let draggedPieceOffsetY = 0;
    let validDropTargets = [];
    let gridLabelMode = 3; // 0: All (inside & outside), 1: Outside only, 2: Inside only, 3: None

    function createBoard() {
        let wrapper = document.getElementById('chessboard-wrapper');
        if (!wrapper) {
            wrapper = document.createElement('div');
            wrapper.id = 'chessboard-wrapper';
            board.parentNode.insertBefore(wrapper, board);
            wrapper.appendChild(board);
        }
        for (let i = 0; i < 64; i++) {
            const square = document.createElement('div');
            square.dataset.index = i;
            square.classList.add('square');
            if ((Math.floor(i / 8) + i % 8) % 2 === 0) {
                square.classList.add('white');
            } else {
                square.classList.add('black');
            }
            square.addEventListener('click', () => handleSquareClick(i));
            square.addEventListener('dragover', (e) => handleDragOver(e, i));
            square.addEventListener('drop', (e) => handleDrop(e, i));
            square.addEventListener('dragenter', (e) => handleDragEnter(e, i));
            square.addEventListener('dragleave', handleDragLeave);
            board.appendChild(square);
        }
        createOutsideLabels();
        updateGridButtonText();
        
        // Position the move arrow inside the wrapper
        const moveArrow = document.getElementById('move-arrow');
        wrapper.appendChild(moveArrow);
    }

    function createOutsideLabels() {
        // Remove any existing outside labels first
        document.querySelectorAll('.outside-label').forEach(el => el.remove());
        
        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const wrapper = document.getElementById('chessboard-wrapper');
        const squareSize = document.querySelector('.square').offsetWidth;
        
        // Create bottom column labels (a-h)
        for (let i = 0; i < 8; i++) {
            const label = document.createElement('div');
            label.classList.add('outside-label', 'column-label', 'bottom-label');
            label.textContent = files[i];
            label.style.left = `${25 + i * squareSize + squareSize/2 - 10}px`;
            label.style.bottom = '5px';
            wrapper.appendChild(label);
        }
        
        // Create left row labels (1-8)
        for (let i = 0; i < 8; i++) {
            const label = document.createElement('div');
            label.classList.add('outside-label', 'row-label', 'left-label');
            label.textContent = 8 - i;
            label.style.left = '5px';
            label.style.top = `${25 + i * squareSize + squareSize/2 - 10}px`;
            wrapper.appendChild(label);
        }
    }

    function updateGridButtonText() {
        // Always display "Grid Labels" regardless of mode
        document.getElementById('toggle-grid-btn').textContent = "Grid Labels";
    }

    function toggleGridLabels() {
        gridLabelMode = (gridLabelMode + 1) % 4;
        updateBoard();
    }

    function handleSquareClick(index) {
        const row = Math.floor(index / 8);
        const col = index % 8;
        const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        if (gameState.selection === 100) {
            if ((gameState.turn_step % 2 === 0 && whiteIndex !== -1) || 
                (gameState.turn_step % 2 === 1 && blackIndex !== -1)) {
                const piece_index = gameState.turn_step % 2 === 0 ? whiteIndex : blackIndex;
                gameState.selection = piece_index;
                gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                    gameState.white_options[piece_index] : 
                    gameState.black_options[piece_index];
                updateBoard();
            }
        } else {
            const move = [col, row];
            const validMove = gameState.valid_moves.some(vm => {
                if (Array.isArray(vm)) {
                    return vm[0] === col && vm[1] === row;
                }
                return false;
            });
            if (validMove) {
                makeMove(gameState.selection, move);
            } else {
                gameState.selection = 100;
                gameState.valid_moves = [];
                updateBoard();
            }
        }
    }

    function handlePromotion(color, index) {
        promoColor = color;
        promoIndex = index;
        promotionOptions.innerHTML = '';
        let selectedPiece = null;
        const pieces = ['queen', 'rook', 'bishop', 'knight'];
        const piecePrefix = color === 'white' ? 'lt' : 'dt';
        pieces.forEach(piece => {
            const option = document.createElement('div');
            option.classList.add('promotion-option');
            const img = document.createElement('img');
            img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}${piecePrefix}60.png`;
            option.appendChild(img);
            option.addEventListener('click', () => {
                if (selectedPiece === piece) {
                    selectPromotion(piece);
                } else {
                    selectedPiece = piece;
                    promotionOptions.querySelectorAll('.promotion-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');
                    selectedPiece = piece;
                }
            });
            promotionOptions.appendChild(option);
        });
        document.addEventListener('click', function closeModal(e) {
            if (!promotionModal.contains(e.target) && selectedPiece) {
                promotionModal.style.display = 'none';
                document.removeEventListener('click', closeModal);
            }
        });
        promotionModal.style.display = 'block';
    }

    function selectPromotion(piece) {
        fetch('/promote', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                color: promoColor,
                piece: piece,
                index: promoIndex
            })
        })
        .then(response => response.json())
        .then(data => {
            Object.assign(gameState, data);
            promotionModal.style.display = 'none';
            updateBoard();
        })
        .catch(error => {
            console.error('Error promoting pawn:', error);
        });
    }

    function updateBoard() {
        const squares = document.querySelectorAll('.square');
        squares.forEach(square => {
            square.innerHTML = '';
            square.classList.remove('last-move-from', 'last-move-to');
            square.classList.remove('valid-move', 'castle-move');
        });
        const outsideLabels = document.querySelectorAll('.outside-label');
        outsideLabels.forEach(label => {
            label.style.display = (gridLabelMode === 0 || gridLabelMode === 1) ? 'block' : 'none';
        });
        squares.forEach(square => {
            const index = parseInt(square.dataset.index);
            const row = Math.floor(index / 8);
            const col = index % 8;
            const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
            const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);
            if (whiteIndex !== -1) {
                const piece = gameState.white_pieces[whiteIndex];
                const img = document.createElement('img');
                img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}lt60.png`;
                img.classList.add('piece-image');
                img.draggable = true;
                img.dataset.pieceIndex = whiteIndex;
                img.dataset.pieceColor = 'white';
                img.addEventListener('dragstart', (e) => handleDragStart(e, whiteIndex, 'white'));
                img.addEventListener('touchstart', (e) => handleTouchStart(e, whiteIndex, 'white'), { passive: false });
                square.appendChild(img);
            } else if (blackIndex !== -1) {
                const piece = gameState.black_pieces[blackIndex];
                const img = document.createElement('img');
                img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}dt60.png`;
                img.classList.add('piece-image');
                img.draggable = true;
                img.dataset.pieceIndex = blackIndex;
                img.dataset.pieceColor = 'black';
                img.addEventListener('dragstart', (e) => handleDragStart(e, blackIndex, 'black'));
                img.addEventListener('touchstart', (e) => handleTouchStart(e, blackIndex, 'black'), { passive: false });
                square.appendChild(img);
            }
            if (gameState.last_move) {
                const [fromCol, fromRow] = gameState.last_move.from;
                const [toCol, toRow] = gameState.last_move.to;
                if (col === fromCol && row === fromRow) {
                    square.classList.add('last-move-from');
                }
                if (col === toCol && row === toRow) {
                    square.classList.add('last-move-to');
                }
            }
            if (gridLabelMode === 0 || gridLabelMode === 2) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                const rowLabel = 8 - Math.floor(index / 8);
                const colLabel = files[index % 8];
                const topLeftLabel = document.createElement('div');
                topLeftLabel.classList.add('grid-label', 'top-left');
                topLeftLabel.textContent = `${colLabel}${rowLabel}`;
                square.appendChild(topLeftLabel);
            }
        });
        if (gameState.valid_moves) {
            gameState.valid_moves.forEach(move => {
                const [col, row] = Array.isArray(move) ? move.slice(0, 2) : move;
                const index = row * 8 + col;
                const square = document.querySelector(`.square[data-index="${index}"]`);
                if (square) {
                    const isValidMove = gameState.valid_moves.some(vm => {
                        if (Array.isArray(vm)) {
                            return vm[0] === col && vm[1] === row;
                        }
                        return false;
                    });
                    const isCastleMove = gameState.valid_moves.some(vm => {
                        if (Array.isArray(vm) && vm.length === 3 && vm[2].includes('castle')) {
                            return vm[0] === col && vm[1] === row;
                        }
                        return false;
                    });
                    if (isValidMove) {
                        square.classList.add('valid-move');
                    }
                    if (isCastleMove) {
                        square.classList.add('castle-move');
                    }
                }
            });
        }
        if (gameState.last_move) {
            requestAnimationFrame(() => {
                drawMoveArrow(gameState.last_move.from, gameState.last_move.to);
            });
        } else {
            clearMoveArrow();
        }
        capturedWhite.textContent = gameState.captured_pieces_white.join(', ');
        capturedBlack.textContent = gameState.captured_pieces_black.join(', ');
        const turnColor = gameState.turn_step % 2 === 0 ? 'WHITE' : 'BLACK';
        turnDisplay.textContent = `Current Turn: ${turnColor}`;
        if (gameState.game_over) {
            checkDisplay.textContent = `${gameState.winner.toUpperCase()} WINS BY CAPTURING THE KING!`;
            checkDisplay.className = 'check-indicator checkmate-notification';
            board.style.pointerEvents = 'none';
        } else if (gameState.checkmate) {
            const inCheck = gameState.check.toUpperCase();
            checkDisplay.textContent = `CHECKMATE! ${inCheck} king can be captured!`;
            checkDisplay.className = 'check-indicator checkmate-notification';
        } else if (gameState.check) {
            checkDisplay.textContent = `${gameState.check.toUpperCase()} IS IN CHECK!`;
            checkDisplay.className = 'check-indicator check-notification';
        } else {
            checkDisplay.textContent = '';
            checkDisplay.className = 'check-indicator';
        }
    }

    function drawMoveArrow(from, to) {
        const arrowContainer = document.getElementById('move-arrow');
        const svg = arrowContainer.querySelector('svg');
        const squareSize = document.querySelector('.square').offsetWidth;
        const wrapper = document.getElementById('chessboard-wrapper');
        
        if (!from || !to || from.length < 2 || to.length < 2) {
            console.error("Invalid move coordinates:", from, to);
            return;
        }
        
        const fromCol = Number(from[0]);
        const fromRow = Number(from[1]);
        const toCol = Number(to[0]);
        const toRow = Number(to[1]);
        
        // Position arrow relative to the chessboard, not the wrapper
        // The wrapper has 25px padding we need to account for
        arrowContainer.style.position = 'absolute';
        arrowContainer.style.left = '0';
        arrowContainer.style.top = '0';
        arrowContainer.style.width = '100%';
        arrowContainer.style.height = '100%';
        arrowContainer.style.pointerEvents = 'none';
        
        // Set svg to match the overall board dimensions
        svg.setAttribute('width', wrapper.offsetWidth);
        svg.setAttribute('height', wrapper.offsetHeight);
        
        // Add padding offset (25px) to the square positions
        const padding = 25;
        const startX = padding + fromCol * squareSize + squareSize / 2;
        const startY = padding + fromRow * squareSize + squareSize / 2;
        const endX = padding + toCol * squareSize + squareSize / 2;
        const endY = padding + toRow * squareSize + squareSize / 2;
        
        const dx = endX - startX;
        const dy = endY - startY;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length === 0) {
            svg.innerHTML = '';
            return;
        }
        
        const unitX = dx / length;
        const unitY = dy / length;
        
        const shortenAmount = squareSize * 0.4; // Shortened arrow to avoid covering pieces
        const newStartX = startX + unitX * shortenAmount;
        const newStartY = startY + unitY * shortenAmount;
        const newEndX = endX - unitX * shortenAmount;
        const newEndY = endY - unitY * shortenAmount;
        
        const strokeWidth = Math.max(2, squareSize / 20); // Thinner stroke
        
        svg.innerHTML = `
            <defs>
                <marker id="arrowhead" 
                       viewBox="0 0 10 10"
                       refX="1"
                       refY="5"
                       markerWidth="4"
                       markerHeight="4"
                       orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#ffaa00"/>
                </marker>
            </defs>
            <line 
                x1="${newStartX}"
                y1="${newStartY}"
                x2="${newEndX}"
                y2="${newEndY}"
                stroke="#ffaa00"
                stroke-width="${strokeWidth}"
                marker-end="url(#arrowhead)"
                stroke-opacity="0.5" />
        `;
    }

    function clearMoveArrow() {
        const arrowContainer = document.getElementById('move-arrow');
        const svg = arrowContainer.querySelector('svg');
        svg.innerHTML = '';
    }

    window.addEventListener('resize', () => {
        if (gameState && gameState.last_move) {
            setTimeout(() => {
                drawMoveArrow(gameState.last_move.from, gameState.last_move.to);
                // Also recreate outside labels as they depend on square size
                createOutsideLabels();
            }, 100);
        }
    });

    function restartGame() {
        board.style.pointerEvents = 'auto';
        fetch('/restart', {
            method: 'POST'
            // No need to send any data as the server will determine the starting turn
        })
        .then(response => response.json())
        .then(data => {
            console.log("Restart data received:", data);
            gameState = data;
            if (!Array.isArray(gameState.valid_moves)) {
                gameState.valid_moves = [];
            }
            gameState.selection = 100;
            clearMoveArrow();
            updateBoard();
        })
        .catch(error => {
            console.error('Error restarting game:', error);
        });
    }

    function toggleSound() {
        if (backgroundMusic.muted) {
            backgroundMusic.muted = false;
            soundIcon.src = '/static/sound-on.png';
            backgroundMusic.play();
        } else {
            backgroundMusic.muted = true;
            soundIcon.src = '/static/sound-off.png';
        }
    }

    function handleDragStart(e, pieceIndex, color) {
        if ((gameState.turn_step % 2 === 0 && color === 'white') || 
            (gameState.turn_step % 2 === 1 && color === 'black')) {
            draggedPiece = e.target;
            draggedPieceIndex = pieceIndex;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', pieceIndex);
            gameState.selection = pieceIndex;
            gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                gameState.white_options[pieceIndex] : 
                gameState.black_options[pieceIndex];
                
            // First determine castle moves to apply the castle-move class first
            const castleMoves = gameState.valid_moves.filter(vm => 
                Array.isArray(vm) && vm.length === 3 && vm[2].includes('castle')
            );
            
            // Then process all valid moves
            validDropTargets = gameState.valid_moves.map(move => {
                const [col, row] = Array.isArray(move) ? move.slice(0, 2) : move;
                return row * 8 + col;
            });
            
            validDropTargets.forEach(index => {
                const square = document.querySelector(`.square[data-index="${index}"]`);
                if (square) {
                    square.classList.add('valid-drop-target');
                    
                    // Check if this is a castling move
                    const row = Math.floor(index / 8);
                    const col = index % 8;
                    const isCastleMove = castleMoves.some(move => 
                        move[0] === col && move[1] === row
                    );
                    
                    if (isCastleMove) {
                        square.classList.add('castle-move');
                    }
                }
            });
            
            setTimeout(() => {
                if (draggedPiece) draggedPiece.classList.add('dragging');
            }, 0);
            
            draggedPiece.addEventListener('dragend', cleanupDrag, { once: true });
        } else {
            e.preventDefault();
        }
    }

    function cleanupDrag() {
        validDropTargets.forEach(index => {
            const square = document.querySelector(`.square[data-index="${index}"]`);
            if (square) {
                square.classList.remove('valid-drop-target');
                square.classList.remove('castle-move'); // Also remove castle-move class
            }
        });
        if (draggedPiece) {
            draggedPiece.classList.remove('dragging');
        }
        draggedPiece = null;
        draggedPieceIndex = -1;
        validDropTargets = [];
    }

    function handleTouchStart(e, pieceIndex, color) {
        if ((gameState.turn_step % 2 === 0 && color === 'white') || 
            (gameState.turn_step % 2 === 1 && color === 'black')) {
            
            e.preventDefault();
            const touch = e.touches[0];
            const target = e.target;
            const clone = target.cloneNode(true);
            clone.classList.add('piece-dragging');
            document.body.appendChild(clone);
            const rect = target.getBoundingClientRect();
            draggedPiece = target;
            draggedPieceIndex = pieceIndex;
            draggedPieceOffsetX = touch.clientX - rect.left - rect.width / 2;
            draggedPieceOffsetY = touch.clientY - rect.top - rect.height / 2;
            clone.style.left = `${touch.clientX - draggedPieceOffsetX}px`;
            clone.style.top = `${touch.clientY - draggedPieceOffsetY}px`;
            gameState.selection = pieceIndex;
            gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                gameState.white_options[pieceIndex] : 
                gameState.black_options[pieceIndex];
                
            // First determine castle moves to apply the castle-move class first
            const castleMoves = gameState.valid_moves.filter(vm => 
                Array.isArray(vm) && vm.length === 3 && vm[2].includes('castle')
            );
            
            validDropTargets = gameState.valid_moves.map(move => {
                const [col, row] = Array.isArray(move) ? move.slice(0, 2) : move;
                return row * 8 + col;
            });
            
            validDropTargets.forEach(index => {
                const square = document.querySelector(`.square[data-index="${index}"]`);
                if (square) {
                    square.classList.add('valid-drop-target');
                    
                    // Check if this is a castling move
                    const row = Math.floor(index / 8);
                    const col = index % 8;
                    const isCastleMove = castleMoves.some(move => 
                        move[0] === col && move[1] === row
                    );
                    
                    if (isCastleMove) {
                        square.classList.add('castle-move');
                    }
                }
            });
            
            document.addEventListener('touchmove', handleTouchMove);
            document.addEventListener('touchend', handleTouchEnd);
            document.addEventListener('touchcancel', cleanupTouch);
            setTimeout(() => {
                if (draggedPiece) {
                    document.addEventListener('touchcancel', cleanupTouch);
                }
            }, 100);
        }
    }

    function cleanupTouch() {
        const clone = document.querySelector('.piece-dragging');
        if (clone) clone.remove();
        validDropTargets.forEach(index => {
            const square = document.querySelector(`.square[data-index="${index}"]`);
            if (square) {
                square.classList.remove('valid-drop-target');
                square.classList.remove('castle-move'); // Also remove castle-move class
            }
        });
        draggedPiece = null;
        draggedPieceIndex = -1;
        validDropTargets = [];
    }

    function handleDragOver(e, index) {
        if (validDropTargets.includes(index)) {
            e.preventDefault();
        }
    }

    function handleDragEnter(e, index) {
        if (validDropTargets.includes(index)) {
            e.currentTarget.classList.add('drag-over');
        }
    }

    function handleDragLeave(e) {
        e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e, index) {
        e.currentTarget.classList.remove('drag-over');
        if (validDropTargets.includes(index)) {
            e.preventDefault();
            makeMove(draggedPieceIndex, [index % 8, Math.floor(index / 8)]);
        }
    }

    function makeMove(pieceIndex, move) {
        const currentPos = gameState.turn_step % 2 === 0 
            ? gameState.white_locations[pieceIndex]
            : gameState.black_locations[pieceIndex];
        fetch('/move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                piece_index: pieceIndex,
                move: move,
                from: currentPos
            })
        })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            if (gameState.promotion) {
                handlePromotion(gameState.promotion.color, gameState.promotion.index);
            } else {
                updateBoard();
            }
        })
        .catch(error => console.error('Error:', error));
    }

    window.onload = () => {
        // Apply initial CSS positioning
        const gameInfo = document.getElementById('game-info');
        const buttonContainer = document.querySelector('.button-container');
        const capturedInfo = document.getElementById('captured-white').parentElement;
        document.body.style.display = 'flex';
        document.body.style.flexDirection = 'column';
        document.body.style.alignItems = 'center';
        createBoard();
        fetch('/state', { method: 'GET' })
            .then(response => response.json())
            .then(data => {
                gameState = data;
                updateBoard();
                backgroundMusic.muted = true;
                soundIcon.src = '/static/sound-off.png';
            })
            .catch(error => {
                console.error('Error fetching game state:', error);
            });
    };
    </script>
</body>
</html>

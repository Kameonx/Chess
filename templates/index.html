<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: white;
            touch-action: none;
        }
        #game-info {
            margin: 20px 0;
            font-size: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        #turn-display {
            margin-bottom: 5px;
        }
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            touch-action: zoom-in;
            position: relative;
            transform: rotate(180deg); /* Rotate the entire board */
        }
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transform: rotate(180deg); /* Rotate each square back to normal */
        }
        .white { background-color: #f0d9b5; }
        .black { background-color: #b58863; }
        #captured-white, #captured-black {
            margin: 10px 0;
            font-size: 20px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            min-height: 40px;
        }
        .captured-piece {
            width: 30px;
            height: 30px;
            margin: 2px;
        }
        .piece-image {
            max-width: 80px;
            max-height: 80px;
            user-select: none; /* Prevent text selection during drag */
        }
        .valid-move {
            background-color: rgba(0, 255, 0, 0.5);
        }
        .castle-move {
            background-color: rgba(0, 0, 255, 0.5) !important; /* Add !important to ensure it takes precedence */
        }
        #restart-btn {
            padding: 10px 20px;
            font-size: 18px;
            margin: 10px 0;
            cursor: pointer;
        }
        .check-indicator {
            font-weight: bold;
        }
        .check-notification {
            color: yellow; /* Change this to your desired color for check */
        }
        .checkmate-notification {
            color: #ff0000;
            font-weight: bold;
            font-size: 28px; /* Make it larger */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5); /* Add shadow for emphasis */
        }
        #promotion-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            text-align: center;
        }
        .promotion-option {
            display: inline-block;
            cursor: pointer;
            margin: 10px;
            padding: 10px;
            border-radius: 5px;
            background-color: #3a3a3a;
            transition: background-color 0.3s;
        }
        .promotion-option:hover {
            background-color: #4a4a4a;
        }
        .promotion-option img {
            width: 60px;
            height: 60px;
        }
        .grid-label {
            position: absolute;
            font-size: 14px;
            color: rgba(180, 180, 180, 0.9); /* Darker text */
        }
        .grid-label.top-left {
            top: 2px;
            left: 2px;
        }
        .grid-label.bottom-right {
            bottom: 2px;
            right: 2px;
        }
        #chessboard-wrapper {
            position: relative;
            padding: 25px;
            margin-bottom: 10px;
        }
        .outside-label {
            position: absolute;
            font-size: 16px;
            color: rgba(180, 180, 180, 0.9);
            text-align: center;
        }
        .column-label {
            width: 100px;
            height: 20px;
        }
        .row-label {
            width: 20px;
            height: 100px;
            line-height: 100px;
        }
        .button-row {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        #restart-btn, #toggle-grid-btn {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
        }
        @media (max-width: 600px) {
            #chessboard-wrapper {
                padding: 20px;
            }
            .column-label {
                width: 50px;
            }
            .row-label {
                height: 50px;
                line-height: 50px;
            }
        }
        .promotion-option.selected {
            background-color: #5a5a5a;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        .piece-dragging {
            opacity: 0.6;
            cursor: grabbing;
            pointer-events: none;
            position: absolute;
            z-index: 1000;
            transform: translate(-50%, -50%);
        }
        .square.drag-over {
            box-shadow: inset 0 0 10px #ffff00;
        }
        .square.valid-drop-target {
            background-color: rgba(0, 255, 0, 0.3);
        }
        .square.valid-drop-target.castle-move {
            background-color: rgba(0, 0, 255, 0.5) !important;
        }
        .last-move-from {
            box-shadow: inset 0 0 0 4px rgba(255, 255, 0, 0.5);
        }
        .last-move-to {
            box-shadow: inset 0 0 0 4px rgba(255, 165, 0, 0.7);
        }
        #move-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            transform: rotate(180deg); /* Rotate the arrow container */
        }
        #move-arrow svg {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        @media (max-width: 600px) {
            #move-arrow {
                transform: scale(0.5) rotate(180deg); /* Rotate the arrow container */
                transform-origin: top left;
            }
        }
        /* Positioning the buttons vertically with consistent size */
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            width: 200px;
            order: 3; /* Move to the end of the flex container */
        }
        #restart-btn, #toggle-grid-btn {
            padding: 10px 0;
            font-size: 18px;
            cursor: pointer;
            width: 100%;
            margin: 0;
        }
        /* Sound icon centered at bottom */
        #sound-icon {
            position: fixed;
            bottom: 20px;
            right: 20px;
            cursor: pointer;
            width: 24px;
            height: 24px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            padding: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        #sound-icon img {
            width: 100%;
            height: 100%;
        }
        /* Remove turn choice button styles */
        .outside-label.bottom-label {
            transform: translateX(-50%);
        }
        .outside-label.left-label {
            transform: translateY(-50%);
        }
        /* Style for the button container and buttons */
        .button-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
            width: 200px;
            order: 3; /* Move to the end of the flex container */
        }
        #restart-btn, #toggle-grid-btn, #ai-btn {
            padding: 10px 0;
            font-size: 18px;
            cursor: pointer;
            width: 100%;
            margin: 0;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s;
        }
        #restart-btn {
            background-color: #d9534f; /* Red color for restart button */
        }
        #restart-btn:hover {
            background-color: #c9302c;
        }
        #toggle-grid-btn {
            background-color: #5bc0de; /* Blue color for grid button */
        }
        #toggle-grid-btn:hover {
            background-color: #46b8da;
        }
        #ai-btn {
            background-color: #5cb85c; /* Green color for AI button */
        }
        #ai-btn:hover {
            background-color: #4cae4c;
        }
        /* Mobile improvements */
        @media (max-width: 768px) {
            #chessboard {
                grid-template-columns: repeat(8, 40px);
                grid-template-rows: repeat(8, 40px);
            }
            
            .piece-image {
                max-width: 35px;
                max-height: 35px;
            }
            
            .button-container {
                width: 100%;
                padding: 0 15px;
                box-sizing: border-box;
            }
            
            .outside-label {
                font-size: 12px;
            }
            
            .grid-label {
                font-size: 10px;
            }
            
            #sound-icon {
                width: 30px;
                height: 30px;
            }
            
            .captured-piece {
                width: 20px;
                height: 20px;
                margin: 1px;
            }
            
            /* Prevent page scrolling when dragging */
            body.dragging {
                overflow: hidden;
                position: fixed;
                width: 100%;
            }
        }

        /* Ensure the dragged piece is positioned correctly */
        .piece-dragging {
            opacity: 0.8;
            cursor: grabbing;
            pointer-events: none;
            position: fixed;
            z-index: 1000;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            transition: none; /* Remove transitions for smoother dragging */
        }

        @media (max-width: 768px) {
            .piece-dragging {
                width: 40px;
                height: 40px;
            }
        }
    </style>
</head>
<body>
    <div id="game-info">
        <div id="turn-display"></div>
        <!-- Removed turn-choice-button -->
        <div id="check-display" class="check-indicator"></div>
    </div>
    
    <div id="chessboard"></div>
    <div id="move-arrow"><svg></svg></div>
    <div id="captured-white">Captured White: <div id="captured-white-list" class="captured-pieces-container"></div></div>
    <div id="captured-black">Captured Black: <div id="captured-black-list" class="captured-pieces-container"></div></div>
    
    <!-- Button container (swapped order) -->
    <div class="button-container">
        <button id="restart-btn" onclick="restartGame()">Restart Game</button>
        <button id="ai-btn" onclick="playVsAI()">Play vs AI</button>
        <button id="toggle-grid-btn" onclick="toggleGridLabels()">Grid Labels</button>
    </div>
    
    <div id="promotion-modal">
        <div style="color: white; margin-bottom: 15px; font-size: 20px;">Choose promotion piece:</div>
        <div id="promotion-options"></div>
    </div>
    <audio id="background-music" src="/audio/Chess Type Beat _ joyful - chess (slowed).mp3" loop muted></audio>
    <div id="sound-icon" onclick="toggleSound()">
        <img src="/static/sound-off.png" alt="Sound Off">
    </div>
    <script>
    const board = document.getElementById('chessboard');
    const capturedWhite = document.getElementById('captured-white-list');
    const capturedBlack = document.getElementById('captured-black-list');
    const restartBtn = document.getElementById('restart-btn');
    const turnDisplay = document.getElementById('turn-display');
    const checkDisplay = document.getElementById('check-display');
    const promotionModal = document.getElementById('promotion-modal');
    const promotionOptions = document.getElementById('promotion-options');
    const backgroundMusic = document.getElementById('background-music');
    const soundIcon = document.getElementById('sound-icon').querySelector('img');
    // Remove turnChoiceBtn and nextGameTurn variables
    let draggedPiece = null;
    let draggedPieceIndex = -1;
    let draggedPieceOffsetX = 0;
    let draggedPieceOffsetY = 0;
    let validDropTargets = [];
    let gridLabelMode = 3; // 0: All (inside & outside), 1: Outside only, 2: Inside only, 3: None
    let playingVsAI = false;
    let gameState = null;

    function createBoard() {
        let wrapper = document.getElementById('chessboard-wrapper');
        if (!wrapper) {
            wrapper = document.createElement('div');
            wrapper.id = 'chessboard-wrapper';
            board.parentNode.insertBefore(wrapper, board);
            wrapper.appendChild(board);
        }
        for (let i = 0; i < 64; i++) {
            const square = document.createElement('div');
            square.dataset.index = i;
            square.classList.add('square');
            if ((Math.floor(i / 8) + i % 8) % 2 === 0) {
                square.classList.add('white');
            } else {
                square.classList.add('black');
            }
            square.addEventListener('click', () => handleSquareClick(i));
            square.addEventListener('dragover', (e) => handleDragOver(e, i));
            square.addEventListener('drop', (e) => handleDrop(e, i));
            square.addEventListener('dragenter', (e) => handleDragEnter(e, i));
            square.addEventListener('dragleave', handleDragLeave);
            board.appendChild(square);
        }
        createOutsideLabels();
        updateGridButtonText();
        
        // Position the move arrow inside the wrapper
        const moveArrow = document.getElementById('move-arrow');
        wrapper.appendChild(moveArrow);
    }

    function createOutsideLabels() {
        // Remove any existing outside labels first
        document.querySelectorAll('.outside-label').forEach(el => el.remove());
        
        const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const wrapper = document.getElementById('chessboard-wrapper');
        const squareSize = document.querySelector('.square').offsetWidth;
        
        // Bottom column labels (a-h) remain in order
        for (let i = 0; i < 8; i++) {
            const label = document.createElement('div');
            label.classList.add('outside-label', 'column-label', 'bottom-label');
            label.textContent = files[i];
            label.style.left = `${25 + i * squareSize + squareSize/2 - 10}px`;
            label.style.bottom = '5px';
            wrapper.appendChild(label);
        }
        
        // Left row labels: show ranks 1 (bottom) to 8 (top)
        for (let i = 0; i < 8; i++) {
            const label = document.createElement('div');
            label.classList.add('outside-label', 'row-label', 'left-label');
            // Instead of 8 - i, we want i+1 but placed in reverse order vertically.
            label.textContent = i + 1;
            // Compute vertical position in reverse: i=0 should be at bottom.
            label.style.left = '5px';
            label.style.top = `${25 + (7 - i) * squareSize + squareSize/2 - 10}px`;
            wrapper.appendChild(label);
        }
    }

    function updateGridButtonText() {
        // Always display "Grid Labels" regardless of mode
        document.getElementById('toggle-grid-btn').textContent = "Grid Labels";
    }

    function toggleGridLabels() {
        gridLabelMode = (gridLabelMode + 1) % 4;
        updateBoard();
    }

    function handleSquareClick(index) {
        const row = Math.floor(index / 8);
        const col = index % 8;
        const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);
        if (gameState.selection === 100) {
            if ((gameState.turn_step % 2 === 0 && whiteIndex !== -1) || 
                (gameState.turn_step % 2 === 1 && blackIndex !== -1)) {
                const piece_index = gameState.turn_step % 2 === 0 ? whiteIndex : blackIndex;
                gameState.selection = piece_index;
                gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                    gameState.white_options[piece_index] : 
                    gameState.black_options[piece_index];
                updateBoard();
            }
        } else {
            const move = [col, row];
            const validMove = gameState.valid_moves.some(vm => {
                if (Array.isArray(vm)) {
                    return vm[0] === col && vm[1] === row;
                }
                return false;
            });
            if (validMove) {
                makeMove(gameState.selection, move);
            } else {
                gameState.selection = 100;
                gameState.valid_moves = [];
                updateBoard();
            }
        }
    }

    function handlePromotion(color, index) {
        promoColor = color;
        promoIndex = index;
        promotionOptions.innerHTML = '';
        let selectedPiece = null;
        const pieces = ['queen', 'rook', 'bishop', 'knight'];
        const piecePrefix = color === 'white' ? 'lt' : 'dt';
        pieces.forEach(piece => {
            const option = document.createElement('div');
            option.classList.add('promotion-option');
            const img = document.createElement('img');
            img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}${piecePrefix}60.png`;
            option.appendChild(img);
            option.addEventListener('click', () => {
                if (selectedPiece === piece) {
                    selectPromotion(piece);
                } else {
                    selectedPiece = piece;
                    promotionOptions.querySelectorAll('.promotion-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    option.classList.add('selected');
                    selectedPiece = piece;
                }
            });
            promotionOptions.appendChild(option);
        });
        document.addEventListener('click', function closeModal(e) {
            if (!promotionModal.contains(e.target) && selectedPiece) {
                promotionModal.style.display = 'none';
                document.removeEventListener('click', closeModal);
            }
        });
        promotionModal.style.display = 'block';
    }

    function selectPromotion(piece) {
        fetch('/promote', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                color: promoColor,
                piece: piece,
                index: promoIndex
            })
        })
        .then(response => response.json())
        .then(data => {
            Object.assign(gameState, data);
            promotionModal.style.display = 'none';
            updateBoard();
        })
        .catch(error => {
            console.error('Error promoting pawn:', error);
        });
    }

    function updateBoard() {
        const squares = document.querySelectorAll('.square');
        squares.forEach(square => {
            square.innerHTML = '';
            square.classList.remove('last-move-from', 'last-move-to');
            square.classList.remove('valid-move', 'castle-move');
        });
        const outsideLabels = document.querySelectorAll('.outside-label');
        outsideLabels.forEach(label => {
            label.style.display = (gridLabelMode === 0 || gridLabelMode === 1) ? 'block' : 'none';
        });
        squares.forEach(square => {
            const index = parseInt(square.dataset.index);
            const row = Math.floor(index / 8);
            const col = index % 8;
            const whiteIndex = gameState.white_locations.findIndex(loc => loc[0] === col && loc[1] === row);
            const blackIndex = gameState.black_locations.findIndex(loc => loc[0] === col && loc[1] === row);
            if (whiteIndex !== -1) {
                const piece = gameState.white_pieces[whiteIndex];
                if (piece) { // Check if piece exists
                    const img = document.createElement('img');
                    img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}lt60.png`;
                    img.classList.add('piece-image');
                    img.draggable = true;
                    img.dataset.pieceIndex = whiteIndex;
                    img.dataset.pieceColor = 'white';
                    img.addEventListener('dragstart', (e) => handleDragStart(e, whiteIndex, 'white'));
                    img.addEventListener('touchstart', (e) => handleTouchStart(e, whiteIndex, 'white'), { passive: false });
                    square.appendChild(img);
                }
            } else if (blackIndex !== -1) {
                const piece = gameState.black_pieces[blackIndex];
                if (piece) { // Check if piece exists
                    const img = document.createElement('img');
                    img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}dt60.png`;
                    img.classList.add('piece-image');
                    img.draggable = true;
                    img.dataset.pieceIndex = blackIndex;
                    img.dataset.pieceColor = 'black';
                    img.addEventListener('dragstart', (e) => handleDragStart(e, blackIndex, 'black'));
                    img.addEventListener('touchstart', (e) => handleTouchStart(e, blackIndex, 'black'), { passive: false });
                    square.appendChild(img);
                }
            }
            if (gameState.last_move) {
                const [fromCol, fromRow] = gameState.last_move.from;
                const [toCol, toRow] = gameState.last_move.to;
                if (col === fromCol && row === fromRow) {
                    square.classList.add('last-move-from');
                }
                if (col === toCol && row === toRow) {
                    square.classList.add('last-move-to');
                }
            }
            if (gridLabelMode === 0 || gridLabelMode === 2) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                // Use the board's internal coordinates (row 0 = rank 1)
                const rowLabel = Math.floor(index / 8) + 1;
                const colLabel = files[index % 8];
                const topLeftLabel = document.createElement('div');
                topLeftLabel.classList.add('grid-label', 'top-left');
                topLeftLabel.textContent = `${colLabel}${rowLabel}`;
                square.appendChild(topLeftLabel);
            }
        });
        if (gameState.valid_moves) {
            gameState.valid_moves.forEach(move => {
                // Check if the move is an array and has at least 2 elements
                if (Array.isArray(move) && move.length >= 2) {
                    const [col, row] = move;
                    const index = row * 8 + col;
                    const square = document.querySelector(`.square[data-index="${index}"]`);
                    
                    if (square) {
                        square.classList.add('valid-move');
                        
                        // Check if this move includes castle info (move.length > 2)
                        if (move.length > 2 && typeof move[2] === 'string' && move[2].includes('castle')) {
                            square.classList.add('castle-move');
                        }
                    }
                }
            });
        }
        if (gameState.last_move) {
            requestAnimationFrame(() => {
                drawMoveArrow(gameState.last_move.from, gameState.last_move.to);
            });
        } else {
            clearMoveArrow();
        }
        
        // Update captured pieces with images instead of text
        updateCapturedPieces(capturedWhite, gameState.captured_pieces_white, 'white');
        updateCapturedPieces(capturedBlack, gameState.captured_pieces_black, 'black');
        
        const turnColor = gameState.turn_step % 2 === 0 ? 'WHITE' : 'BLACK';
        if (playingVsAI) {
            const playerTurnText = gameState.turn_step % 2 === 0 ? 'WHITE (You)' : 'BLACK (AI)';
            turnDisplay.textContent = `Current Turn: ${playerTurnText} - Playing vs AI`;
        } else {
            turnDisplay.textContent = `Current Turn: ${turnColor}`;
        }
        if (gameState.game_over) {
            checkDisplay.textContent = `${gameState.winner.toUpperCase()} WINS BY CAPTURING THE KING!`;
            checkDisplay.className = 'check-indicator checkmate-notification';
            board.style.pointerEvents = 'none';
        } else if (gameState.checkmate) {
            const inCheck = gameState.check.toUpperCase();
            checkDisplay.textContent = `CHECKMATE! ${inCheck} king can be captured!`;
            checkDisplay.className = 'check-indicator checkmate-notification';
        } else if (gameState.check) {
            checkDisplay.textContent = `${gameState.check.toUpperCase()} IS IN CHECK!`;
            checkDisplay.className = 'check-indicator check-notification';
        } else {
            checkDisplay.textContent = '';
            checkDisplay.className = 'check-indicator';
        }
    }
    
    function updateCapturedPieces(container, capturedPieces, opponentColor) {
        // Clear the container
        container.innerHTML = '';
        
        // If no captured pieces, return early
        if (!capturedPieces || capturedPieces.length === 0) {
            return;
        }
        
        // Group pieces by type for more organized display
        const pieceCount = {};
        capturedPieces.forEach(piece => {
            if (!pieceCount[piece]) {
                pieceCount[piece] = 0;
            }
            pieceCount[piece]++;
        });
        
        // Display each type of captured piece with count
        Object.keys(pieceCount).forEach(piece => {
            const pieceGroup = document.createElement('div');
            pieceGroup.style.display = 'inline-flex';
            pieceGroup.style.alignItems = 'center';
            pieceGroup.style.margin = '0 5px';
            
            // Create the piece image
            const img = document.createElement('img');
            const colorPrefix = opponentColor === 'white' ? 'lt' : 'dt';
            img.src = `/images/Chess_${piece === 'knight' ? 'n' : piece[0]}${colorPrefix}60.png`;
            img.className = 'captured-piece';
            pieceGroup.appendChild(img);
            
            // Add count badge if more than one
            if (pieceCount[piece] > 1) {
                const count = document.createElement('span');
                count.textContent = `×${pieceCount[piece]}`;
                count.style.fontSize = '14px';
                count.style.margin = '0 3px';
                pieceGroup.appendChild(count);
            }
            
            container.appendChild(pieceGroup);
        });
    }

    function drawMoveArrow(from, to) {
        const arrowContainer = document.getElementById('move-arrow');
        const svg = arrowContainer.querySelector('svg');
        const squareSize = document.querySelector('.square').offsetWidth;
        const wrapper = document.getElementById('chessboard-wrapper');
        
        if (!from || !to || from.length < 2) {
            console.error("Invalid move coordinates:", from, to);
            return;
        }
        
        const fromCol = Number(from[0]);
        const fromRow = Number(from[1]);
        const toCol = Number(to[0]);
        const toRow = Number(to[1]);
        
        // Position arrow relative to the chessboard, not the wrapper
        // The wrapper has 25px padding we need to account for
        arrowContainer.style.position = 'absolute';
        arrowContainer.style.left = '0';
        arrowContainer.style.top = '0';
        arrowContainer.style.width = '100%';
        arrowContainer.style.height = '100%';
        arrowContainer.style.pointerEvents = 'none';
        
        // Set svg to match the overall board dimensions
        svg.setAttribute('width', wrapper.offsetWidth);
        svg.setAttribute('height', wrapper.offsetHeight);
        
        // Add padding offset (25px) to the square positions
        const padding = 25;
        const startX = padding + fromCol * squareSize + squareSize / 2;
        const startY = padding + fromRow * squareSize + squareSize / 2;
        const endX = padding + toCol * squareSize + squareSize / 2;
        const endY = padding + toRow * squareSize + squareSize / 2;
        
        const dx = endX - startX;
        const dy = endY - startY;
        const length = Math.sqrt(dx * dx + dy * dy);
        
        if (length === 0) {
            svg.innerHTML = '';
            return;
        }
        
        const unitX = dx / length;
        const unitY = dy / length;
        
        const shortenAmount = squareSize * 0.4; // Shortened arrow to avoid covering pieces
        const newStartX = startX + unitX * shortenAmount;
        const newStartY = startY + unitY * shortenAmount;
        const newEndX = endX - unitX * shortenAmount;
        const newEndY = endY - unitY * shortenAmount;
        
        const strokeWidth = Math.max(2, squareSize / 20); // Thinner stroke
        
        svg.innerHTML = `
            <defs>
                <marker id="arrowhead" 
                       viewBox="0 0 10 10"
                       refX="1"
                       refY="5"
                       markerWidth="4"
                       markerHeight="4"
                       orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#ffaa00"/>
                </marker>
            </defs>
            <line 
                x1="${newStartX}"
                y1="${newStartY}"
                x2="${newEndX}"
                y2="${newEndY}"
                stroke="#ffaa00"
                stroke-width="${strokeWidth}"
                marker-end="url(#arrowhead)"
                stroke-opacity="0.5" />
        `;
    }

    function clearMoveArrow() {
        const arrowContainer = document.getElementById('move-arrow');
        const svg = arrowContainer.querySelector('svg');
        svg.innerHTML = '';
    }

    window.addEventListener('resize', () => {
        if (gameState && gameState.last_move) {
            setTimeout(() => {
                drawMoveArrow(gameState.last_move.from, gameState.last_move.to);
                // Also recreate outside labels as they depend on square size
                createOutsideLabels();
            }, 100);
        }
    });

    function restartGame() {
        board.style.pointerEvents = 'auto';
        // Do not force playingVsAI to false
        // Send the current vsAI flag so that in PvP mode (vsAI is false) the game resets PvP,
        // and in AI mode (vsAI true), the game resets the AI mode.
        fetch('/restart', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ vsAI: playingVsAI, aiColor: 'black' })
        })
        .then(response => response.json())
        .then(data => {
            console.log("Restart data received:", data);
            gameState = data;
            if (!Array.isArray(gameState.valid_moves)) {
                gameState.valid_moves = [];
            }
            gameState.selection = 100;
            clearMoveArrow();
            updateBoard();
        })
        .catch(error => {
            console.error('Error restarting game:', error);
        });
    }

    function toggleSound() {
        if (backgroundMusic.muted) {
            backgroundMusic.muted = false;
            soundIcon.src = '/static/sound-on.png';
            backgroundMusic.play();
        } else {
            backgroundMusic.muted = true;
            soundIcon.src = '/static/sound-off.png';
        }
    }

    function handleDragStart(e, pieceIndex, color) {
        if ((gameState.turn_step % 2 === 0 && color === 'white') || 
            (gameState.turn_step % 2 === 1 && color === 'black')) {
            draggedPiece = e.target;
            draggedPieceIndex = pieceIndex;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', pieceIndex);
            gameState.selection = pieceIndex;
            gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                gameState.white_options[pieceIndex] : 
                gameState.black_options[pieceIndex];
                
            // First determine castle moves to apply the castle-move class first
            const castleMoves = gameState.valid_moves.filter(vm => 
                Array.isArray(vm) && vm.length > 2 && typeof vm[2] === 'string' && vm[2].includes('castle')
            );
            
            validDropTargets = gameState.valid_moves.map(move => {
                const [col, row] = Array.isArray(move) ? move.slice(0, 2) : move;
                return row * 8 + col;
            });
            
            validDropTargets.forEach(index => {
                const square = document.querySelector(`.square[data-index="${index}"]`);
                if (square) {
                    square.classList.add('valid-drop-target');
                    
                    // Check if this is a castling move
                    const row = Math.floor(index / 8);
                    const col = index % 8;
                    const isCastleMove = castleMoves.some(move => 
                        move[0] === col && move[1] === row
                    );
                    
                    if (isCastleMove) {
                        square.classList.add('castle-move');
                    }
                }
            });
            
            setTimeout(() => {
                if (draggedPiece) draggedPiece.classList.add('dragging');
            }, 0);
            
            draggedPiece.addEventListener('dragend', cleanupDrag, { once: true });
        } else {
            e.preventDefault();
        }
    }

    function cleanupDrag() {
        validDropTargets.forEach(index => {
            const square = document.querySelector(`.square[data-index="${index}"]`);
            if (square) {
                square.classList.remove('valid-drop-target');
                square.classList.remove('castle-move'); // Also remove castle-move class
            }
        });
        if (draggedPiece) {
            draggedPiece.classList.remove('dragging');
        }
        draggedPiece = null;
        draggedPieceIndex = -1;
        validDropTargets = [];
    }

    function handleTouchStart(e, pieceIndex, color) {
        if ((gameState.turn_step % 2 === 0 && color === 'white') || 
            (gameState.turn_step % 2 === 1 && color === 'black')) {
            
            e.preventDefault();
            const touch = e.touches[0];
            const target = e.target;
            
            // Remove any existing clones first to prevent duplicates
            document.querySelectorAll('.piece-dragging').forEach(el => el.remove());
            
            // Create a clone with improved positioning
            const clone = target.cloneNode(true);
            clone.classList.add('piece-dragging');
            document.body.appendChild(clone);
            
            // Get accurate position information
            const rect = target.getBoundingClientRect();
            draggedPiece = target;
            draggedPieceIndex = pieceIndex;
            
            // Set offsets to center of piece for better accuracy
            draggedPieceOffsetX = rect.width / 2;
            draggedPieceOffsetY = rect.height / 2;
            
            // Position the clone centered at touch point
            clone.style.left = `${touch.clientX}px`;
            clone.style.top = `${touch.clientY}px`;
            
            gameState.selection = pieceIndex;
            gameState.valid_moves = gameState.turn_step % 2 === 0 ? 
                gameState.white_options[pieceIndex] : 
                gameState.black_options[pieceIndex];
                
            // Show valid move indicators
            const castleMoves = gameState.valid_moves.filter(vm => 
                Array.isArray(vm) && vm.length > 2 && typeof vm[2] === 'string' && vm[2].includes('castle')
            );
            
            validDropTargets = gameState.valid_moves.map(move => {
                const [col, row] = Array.isArray(move) ? move.slice(0, 2) : move;
                return row * 8 + col;
            });
            
            validDropTargets.forEach(index => {
                const square = document.querySelector(`.square[data-index="${index}"]`);
                if (square) {
                    square.classList.add('valid-drop-target');
                    
                    // Check if this is a castling move
                    const row = Math.floor(index / 8);
                    const col = index % 8;
                    const isCastleMove = castleMoves.some(move => 
                        move[0] === col && move[1] === row
                    );
                    
                    if (isCastleMove) {
                        square.classList.add('castle-move');
                    }
                }
            });
            
            // Add all necessary event listeners
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { once: true });
            document.addEventListener('touchcancel', cleanupTouch, { once: true });
        }
    }

    function handleTouchMove(e) {
        e.preventDefault(); // This is critical for drag operations
        if (!draggedPiece) return;
        
        const touch = e.touches[0];
        const clone = document.querySelector('.piece-dragging');
        if (clone) {
            // Position the clone at the center of the touch point
            clone.style.left = `${touch.clientX - draggedPieceOffsetX}px`;
            clone.style.top = `${touch.clientY - draggedPieceOffsetY}px`;
            
            // Highlight the square under the touch
            const elementsAtPoint = document.elementsFromPoint(touch.clientX, touch.clientY);
            const squareUnderTouch = elementsAtPoint.find(el => el.classList.contains('square'));
            
            // Remove hover class from all squares
            document.querySelectorAll('.square.drag-over').forEach(sq => {
                if (sq !== squareUnderTouch) {
                    sq.classList.remove('drag-over');
                }
            });
            
            // Add hover class to the square under the touch
            if (squareUnderTouch) {
                const squareIndex = parseInt(squareUnderTouch.dataset.index);
                if (validDropTargets.includes(squareIndex)) {
                    squareUnderTouch.classList.add('drag-over');
                }
            }
        }
    }
    
    function handleTouchEnd(e) {
        if (!draggedPiece) return;
        
        e.preventDefault();
        
        const touch = e.changedTouches[0];
        const elementsAtPoint = document.elementsFromPoint(touch.clientX, touch.clientY);
        const squareUnderTouch = elementsAtPoint.find(el => el.classList.contains('square'));
        
        if (squareUnderTouch) {
            const squareIndex = parseInt(squareUnderTouch.dataset.index);
            if (validDropTargets.includes(squareIndex)) {
                makeMove(draggedPieceIndex, [squareIndex % 8, Math.floor(squareIndex / 8)]);
            }
        }
        
        cleanupTouch();
    }

    function cleanupTouch() {
        // Remove the clone
        document.querySelectorAll('.piece-dragging').forEach(clone => clone.remove());
        
        // Clean up all drag-related classes
        document.querySelectorAll('.valid-drop-target').forEach(square => {
            square.classList.remove('valid-drop-target');
            square.classList.remove('castle-move');
            square.classList.remove('drag-over');
        });
        
        // Remove event listeners
        document.removeEventListener('touchmove', handleTouchMove);
        document.removeEventListener('touchend', handleTouchEnd);
        document.removeEventListener('touchcancel', cleanupTouch);
        
        // Reset variables
        draggedPiece = null;
        draggedPieceIndex = -1;
        validDropTargets = [];
    }

    function handleDragOver(e, index) {
        if (validDropTargets.includes(index)) {
            e.preventDefault();
        }
    }

    function handleDragEnter(e, index) {
        if (validDropTargets.includes(index)) {
            e.currentTarget.classList.add('drag-over');
        }
    }

    function handleDragLeave(e) {
        e.currentTarget.classList.remove('drag-over');
    }

    function handleDrop(e, index) {
        e.currentTarget.classList.remove('drag-over');
        if (validDropTargets.includes(index)) {
            e.preventDefault();
            makeMove(draggedPieceIndex, [index % 8, Math.floor(index / 8)]);
        }
    }

    function makeMove(pieceIndex, move) {
        const currentPos = gameState.turn_step % 2 === 0 
            ? gameState.white_locations[pieceIndex] 
            : gameState.black_locations[pieceIndex];
        
        // Create the move request payload
        const moveData = {
            piece_index: pieceIndex,
            move: move,
            from: currentPos,
            vs_ai: playingVsAI
        };

        fetch('/move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(moveData)
        })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            if (gameState.promotion) {
                handlePromotion(gameState.promotion.color, gameState.promotion.index);
            } else {
                updateBoard();
                // Check if AI needs to make a move
                if (playingVsAI && !gameState.game_over && gameState.turn_step % 2 === 1) {
                    console.log("Requesting AI move...");
                    // Add a slight delay so the player can see what happened
                    setTimeout(() => {
                        requestAIMove();
                    }, 500);
                }
            }
        })
        .catch(error => console.error('Error:', error));
    }

    function requestAIMove() {
        // Add a "thinking" indicator
        turnDisplay.textContent = "AI is thinking...";
        
        fetch('/ai_move', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                game_state: gameState
            })
        })
        .then(response => response.json())
        .then(data => {
            gameState = data;
            if (gameState.promotion) {
                // Auto select queen for AI promotion
                fetch('/promote', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        color: gameState.promotion.color,
                        piece: 'queen',
                        index: gameState.promotion.index
                    })
                })
                .then(response => response.json())
                .then(promotionData => {
                    Object.assign(gameState, promotionData);
                    updateBoard();
                });
            } else {
                updateBoard();
            }
        })
        .catch(error => {
            console.error('Error getting AI move:', error);
            turnDisplay.textContent = `Current Turn: BLACK (AI)`;
        });
    }

    function playVsAI() {
        // Start a new game with white and activate AI mode
        playingVsAI = true;
        fetch('/restart', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                vsAI: true,
                aiColor: 'black'
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log("AI Game started:", data);
            gameState = data;
            if (!Array.isArray(gameState.valid_moves)) {
                gameState.valid_moves = [];
            }
            gameState.selection = 100;
            clearMoveArrow();
            updateBoard();
            document.getElementById('ai-btn').textContent = "Playing vs AI";
            // Update display to show playing against AI
            turnDisplay.textContent = `Current Turn: WHITE (You) - Playing vs AI`;
        })
        .catch(error => {
            console.error('Error starting AI game:', error);
        });
    }

    window.onload = () => {
        // Apply initial CSS positioning
        const gameInfo = document.getElementById('game-info');
        const buttonContainer = document.querySelector('.button-container');
        const capturedInfo = document.getElementById('captured-white').parentElement;
        document.body.style.display = 'flex';
        document.body.style.flexDirection = 'column';
        document.body.style.alignItems = 'center';
        createBoard();
        fetch('/state', { method: 'GET' })
            .then(response => response.json())
            .then(data => {
                gameState = data;
                updateBoard();
                backgroundMusic.muted = true;
                soundIcon.src = '/static/sound-off.png';
            })
            .catch(error => {
                console.error('Error fetching game state:', error);
            });
    };
    </script>
</body>
</html>
